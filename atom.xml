<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence of Heart</title>
  <subtitle>最怕彷徨无前</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-24T05:19:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JacenTsao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker学习,常用指令</title>
    <link href="http://yoursite.com/2017/01/24/Docker%E5%AD%A6%E4%B9%A0-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/01/24/Docker学习-常用指令/</id>
    <published>2017-01-24T04:29:04.000Z</published>
    <updated>2017-01-24T05:19:29.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离， 属于操作系统层面的虚拟化技术。</p>
<a id="more"></a>
<h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><ul>
<li>docker run imagename //运行改image做为container,不存在则会从Docker hub获取并运行</li>
<li>docker ps //获取正在运行的镜像 -a 所有的镜像</li>
<li>touch Dockerfile //创建docker脚本</li>
<li>cat Dockerfile //查看脚本</li>
<li>docker build -t docker-whale . //创建镜像, -t打tag,后面的.(表示当前目录)不能少</li>
<li>docker tag 7d9495d03763 maryatdocker/docker-whale:latest 标记docker镜像</li>
<li>docker login 登录</li>
<li>docker push maryatdocker/docker-whale 上传到docker hub</li>
<li>docker rmi -f 7d9495d03763/imagename 移除镜像</li>
<li>docker run yourusername/docker-whale</li>
<li>docker images 查看所有镜像</li>
<li>docker rmi $(docker images -q -f dangling=true) 删除无用的悬浮镜像 </li>
<li>docker exec  -it webserver bash 运行命令行并启动</li>
<li>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 提交更新,创建镜像<strong>谨慎使用,因为会对容器环境照成较大影响</strong> //docker commit  –author “Tao Wang <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x74;&#x77;&#97;&#110;&#x67;&#x32;&#50;&#49;&#x38;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;">&#x74;&#x77;&#97;&#110;&#x67;&#x32;&#50;&#49;&#x38;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a>“  –message “修改了默认网页” webserver  nginx:v2</li>
<li>docer diff NAMES 查看永久性更新</li>
<li>docker history nginx:v2 查看历史更新</li>
<li>docker rm  删除容器</li>
<li>docker run -it -–entrypoint /bin/bash  karalabe/xgo-latest 强制使用bash启动docker镜像</li>
<li>docker run -it -v /Volumes/Work/go/src/golang.org:/src golang/mobile /bin/bash 挂载宿主机目录到容器</li>
<li>sudo yum upgrade docker 更新docker</li>
<li>docker cp 2e8a06b7cff6:/gopath/src/golang.org/x/mobile/example/GoHello/app/src  Storage-2e8a06b7cff6/</li>
</ul>
<p>####tag本地镜像并提交到docker仓库<br>step1——找到本地镜像的ID：docker images</p>
<p>step2——登陆Hub：docker login –username=username –password=password –email=email</p>
<p>step3——tag：docker tag <imageid> <namespace>/<image name="">:<version tag="" eg="" latest=""></version></image></namespace></imageid></p>
<p>step4——push镜像：docker push <namespace>/<image name=""></image></namespace></p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li>mkdir test</li>
<li>cd test</li>
<li>touch Dockerfile</li>
</ul>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ol>
<li>FROM nginx 指定基础镜像,这个是必须的(可以指定一个空白镜像名为scratch)</li>
<li>RUN  没一个RUN代表一层,因此同一个目的的RUN通过&amp;&amp;合并命令,浓缩到一层 (层数限制旧版42,新版127)</li>
<li>COPY  package.json /usr/src/app/ ||  hom?.txt /mydir/</li>
<li>ADD  ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /  src可以是url,加强版的COPY,还可移植性解压缩</li>
<li>docker build -t docker-whale . docker build [选项] &lt;上下文路径/URL/-&gt; .代表当前目录 -t代表tag</li>
</ol>
<h3 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h3><p>Docker包括三个基本概念,包含了Docker的整个生命周期</p>
<ul>
<li>镜像(Image)</li>
<li>容器(Container)</li>
<li>仓库(Repository)</li>
</ul>
<h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p>Docker镜像,相当于一个root文件系统(操作系统分为内核和用户空间,内核启动后,会挂载root文件系统为用户空间提供支持),镜像不包含任何<strong>动态数据</strong>.提供容器运行时所需的程序、库、资 源、配置等文件外,还包含了一些为运行时准备的一些配置参数（如匿名卷、环境 变量、用户等）.</p>
<h5 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h5><p>镜像包含操作系统完整的root文件系统,体积较大,Docker设计时,采用了<a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="external">Union FS</a>技术,分层存储的架构.</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生 改变，后一层上的任何改变只发生在自己这一层,任何额外的东西应该在该层构建结束前清理掉。</p>
<h4 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>类比于面向对象程序设计中 的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h4&gt;&lt;p&gt;Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离， 属于操作系统层面的虚拟化技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>2017阅读记录</title>
    <link href="http://yoursite.com/2017/01/24/2017%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/01/24/2017阅读记录/</id>
    <published>2017-01-23T23:44:39.000Z</published>
    <updated>2017-01-23T23:44:53.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些好的技术文章</title>
    <link href="http://yoursite.com/2017/01/22/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    <id>http://yoursite.com/2017/01/22/一些好的技术文章/</id>
    <published>2017-01-22T04:58:08.000Z</published>
    <updated>2017-01-22T05:08:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文旨在收集一些个人比较感兴趣的技术类的文章,希望更多的成长学习.</p>
<h3 id="Linux类"><a href="#Linux类" class="headerlink" title="Linux类"></a>Linux类</h3><ol>
<li><a href="http://blog.chinaunix.net/uid-23069658-id-3142046.html" target="_blank" rel="external">Linux系统中“动态库”和“静态库”那点事儿</a>.  </li>
<li><a href="https://www.gitbook.com/book/leon_lizi/-framework-/details" target="_blank" rel="external">静态库与动态库的使用</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文旨在收集一些个人比较感兴趣的技术类的文章,希望更多的成长学习.&lt;/p&gt;
&lt;h3 id=&quot;Linux类&quot;&gt;&lt;a href=&quot;#Linux类&quot; class=&quot;headerlink&quot; title=&quot;Linux类&quot;&gt;&lt;/a&gt;Linux类&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux系统中动态库和静态库</title>
    <link href="http://yoursite.com/2017/01/22/Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://yoursite.com/2017/01/22/Linux系统中动态库和静态库/</id>
    <published>2017-01-22T00:40:53.000Z</published>
    <updated>2017-01-22T04:23:19.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="原文转载自wjlkoorey的博客"><a href="#原文转载自wjlkoorey的博客" class="headerlink" title="原文转载自wjlkoorey的博客"></a>原文转载自<a href="http://blog.chinaunix.net/uid-23069658-id-3142046.html" target="_blank" rel="external">wjlkoorey的博客</a></h5><p>最近一直在学习go语言跨平台编译,在这个过程中也学习了其它很多的内容,今天回顾一下Linux系统下动态库(.so)和静态(.a)的程序那些猫腻.在这之前，我们需要了解一下源代码到可执行程序之间到底发生了什么神奇而美妙的事情。</p>
<p>在Linux操作系统中，普遍使用ELF格式作为可执行程序或者程序生成过程中的中间格式。ELF（Executable and Linking Format，可执行连接格式）是UNIX系统实验室（USL）作为应用程序二进制接口（Application BinaryInterface，ABI）而开发和发布的。工具接口标准委员会（TIS）选择了正在发展中的ELF标准作为工作在32位Intel体系上不同操作系统之间可移植的二进制文件格式。源代码到可执行程序的转换时需要经历如下图所示的过程：</p>
<p><img src="https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcRVaYfvML9MiCHmqr9KBqadX6_DbW8XIiJXlUttBvbfuwWG4Wv3" alt="image"></p>
<ul>
<li>编译是把高级语言编写的程序转换为对应处理器的汇编语言的过程.从本质上来说,编译是一个文本转换的过程.对嵌入式系统而言,一般要把用C语言编写的程序转换成处理器的会变代码.编译过程包含了C语言的语法解析和汇编代码的生成两个步骤.编译一般是逐个文件进行的,对于一个C语言编写的文件,可能还需要进行预处理.</li>
<li>汇编是从会变语言程序生成目标系统的二进制代码(机器码)的过程,机器码的生成和处理器有密切的关系.相对于编译过程的语法解析,汇编的过程相对简单.这是因为对于一款特定的处理器,其汇编语言和二进制的机器代码是一一对应的.汇编过程的输入是汇编代码,这个汇编代码可能来源于编译过程的输出,也可以是直接使用汇编语言书写的程序.</li>
<li>连接是指将汇编生成的多段机器代码组合成一个可执行程序.一般来说,通过汇编和汇编过程,每个源文件将生成一个目标文件.连接器的作用是将这些目标文件组合起来,组合的过程包括了代码段,数据段等部分的合并,以及添加相应的头文件</li>
</ul>
<p>GCC是Linux下主要的程序生成工具,它除了汇编器,编译器,连接器外,还包括一些辅助工具.在下面的分析过程中我会教大家这些工具的基本使用方法.</p>
<p> 作为UNIX操作系统的一种，Linux的操作系统提供了一系列的接口，这些接口被称为系统调用（System Call）。在UNIX的理念中，系统调用“提供的是机制，而不是策略“。C语言的库函数通过调用系统调用来实现，库函数对上层提供了C语言库文件的接口。在应用程序层，通过调用C语言库函数和系统调用来实现功能。一般来说，应用程序大多使用C语言库函数实现其功能，较少使用系统调用。</p>
<p> 那么最后的可执行文件到底是什么样子呢？前面已经说过，这里我们不深入分析ELF文件的格式，只是给出它的一个结构图和一些简单的说明，以方便大家理解。</p>
<p>ELF文件格式包括三种主要的类型：可执行文件、可重定向文件、共享库。</p>
<h4 id="1-可执行文件"><a href="#1-可执行文件" class="headerlink" title="1.可执行文件"></a>1.可执行文件</h4><p>可执行文件包含了代码和数据，是可以直接运行的程序。</p>
<h4 id="2-可重定向文件"><a href="#2-可重定向文件" class="headerlink" title="2.可重定向文件"></a>2.可重定向文件</h4><p>可重定向文件又称为目标文件，它包含了代码和数据（这些数据是和其他重定位文件和共享的object文件一起连接时使用的）。</p>
<p>*.o文件参与程序的连接（创建一个程序）和程序的执行（运行一个程序），它提供了一个方便有效的方法来用并行的视角看待文件的内容，这些*.o文件的活动可以反映出不同的需要。</p>
<p>Linux下，我们可以用gcc -c编译源文件时可将其编译成*.o格式。</p>
<h4 id="3-共享库"><a href="#3-共享库" class="headerlink" title="3.共享库"></a>3.共享库</h4><p>也称为动态库文件，它包含了代码和数据（这些数据是在连接时候被连接器ld和运行时动态连接器使用的）。动态连接器可能称为ld.so.1，libc.so.1或者 ld-linux.so.1。</p>
<p>一个ELF文件从连接器（Linker）的角度看，是一些节的集合；从程序加载器（Loader）的角度看，它是一些段（Segments）的集合。ELF格式的程序和共享库具有相同的结构，只是段的集合和节的集合上有些不同。</p>
<h3 id="那么到底什么是库呢？"><a href="#那么到底什么是库呢？" class="headerlink" title="那么到底什么是库呢？"></a>那么到底什么是库呢？</h3><p>库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。</p>
<p>静态库：这类库的名字一般是libxxx.a，xxx为库的名字。利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中，他的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。</p>
<p>动态库：这类库的名字一般是libxxx.M.N.so，同样的xxx为库的名字，M是库的主版本号，N是库的副版本号。当然也可以不要版本号，但名字必须有。相对于静态函数库，动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。linux系统有几个重要的目录存放相应的函数库，如/lib /usr/lib。</p>
<p>当要使用静态的程序库时，连接器会找出程序所需的函数，然后将它们拷贝到执行文件，由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。然而，对动态库而言，就不是这样。动态库会在执行程序内留下一个标记指明当程序执行时，首先必须载入这个库。由于动态库节省空间，linux下进行连接的缺省操作是首先连接动态库，也就是说，如果同时存在静态和动态库，不特别指定的话，将与动态库相连接。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;原文转载自wjlkoorey的博客&quot;&gt;&lt;a href=&quot;#原文转载自wjlkoorey的博客&quot; class=&quot;headerlink&quot; title=&quot;原文转载自wjlkoorey的博客&quot;&gt;&lt;/a&gt;原文转载自&lt;a href=&quot;http://blog.chinaunix
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="动态库" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
      <category term="静态库" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Android数据持久化</title>
    <link href="http://yoursite.com/2017/01/19/Android%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2017/01/19/Android数据持久化/</id>
    <published>2017-01-19T08:18:48.000Z</published>
    <updated>2017-01-19T08:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天晚上Android项目组的小伙伴一起聊了一下Android数据持久化的几种方式外加一些项目中的总结吧.突然发现一些不怎么用的东西都已经快忘光了,比如说ContentProvider + LoadManger + URIMatcher + CursorAdapter,今天突然提到LoadManager感觉像是一个没接触过的东西,被小伙伴提了一下才记得有这个类的存在,更别提ContentObserver了.有点跑题了还是聊一下Android的数据持久化策略吧!<br><a id="more"></a></p>
<p>##Android数据持久化的方式<br>总所周知,Android共有五种数据持久化的方式,这里是<a href="https://developer.android.com/guide/topics/data/data-storage.html" target="_blank" rel="external">官方文档</a>.通过阅读API Guidance可知,这其中方式分别如下:</p>
<p>###1. SharePreference<br>通常用于存储一些本地化的配置文件,主要分为读和取,操作如下:</p>
<p>1.写入操作</p>
<pre><code>// We need an Editor object to make preference changes.
  // All objects are from android.context.Context
SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
SharedPreferences.Editor editor = settings.edit();
editor.putBoolean(&quot;silentMode&quot;, mSilentMode);
// Commit the edits!
editor.commit();           
    //finally we can see these file in data/data/packagename/shared_preference if your device has been rooted;   
</code></pre><p>2.读取操作</p>
<pre><code>// Restore preferences
SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
//false stands for the default value, you can customize yourself
boolean silent = settings.getBoolean(&quot;silentMode&quot;, false);
</code></pre><p>###2. Internal Storage<br>第一点提到的SharePreference存储的方式最终存放的位置就是在Internal Storage中</p>
<pre><code>String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;
//finally the file path is data/data/packagename/files/hello_file
//and there are kinds of MODE(MODE_PRIVATE,MODE_APPEND,MODE_WORLD_READABLE,MODE_WORLD_WRITABLE)
FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);
fos.write(string.getBytes());
fos.close();                    
</code></pre><p>值得注意的是从API 17开MODE_WORLD_READABLE跟MODE_WORLD_WRITABLE已经是deprecated的状态.从API 23开始,由于谷歌收紧了Android系统的权限(Android越来越封闭,苹果越来越开放,目的都是为了体验越来越好!),如果还使用这两个属性会直接抛出异常SecurityException.因此如果你的应用的TargetVersion在API 23,那么如果你想共享应用的内部数据则只能通过主动分享的方式发起共享,详见<a href="https://developer.android.com/training/secure-file-sharing/index.html" target="_blank" rel="external">参考文档</a>.</p>
<p>正如官方文档所提,如果想要存储静态文件,比如说应用的铃声之类的文件,可以放在项目的res/raw/路径下,通过openRawResource(R.raw.fileId)获取对应的资源文件.</p>
<p>####保存Cache文件<br>通过getCacheDir()可以返回app内部的cache文件,该目录即data/data/packagename/cache由系统维护,但是谷歌的官方建议是自行维护1MB左右,该目录会随着应用卸载而被清理掉.其他诸如getFileDir(),getDir()会在后文有个总结性的说明.</p>
<p>###3. External Storage<br>Android的外部存储可以分为可卸载的存储例如SD卡,以及不可卸载的内部存储(Internal Storage).通过USB文件传输模式连接的时候,用户可以对外部存储进行操作.</p>
<p>当用户挂载外部存储或者移除外部存储的时候,应用就无法操作外部存储了.同时外部存储的全局可读特性也决定了它本身并没有安全性可言.</p>
<p>####获取访问外部存储的权限<br>如果你的应用需要读写外部存储则需要在manifest文件中配置如下权限:</p>
<pre><code>&lt;manifest ...&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
    ...
&lt;/manifest&gt;        
</code></pre><p>如果只需要读取权限只需申明READ_EXTERNAL_STORAGE权限即可;如果需要读写权限只需要申明WRITE_EXTERNAL_STORAGE权限即可,因为系统会同时声明读取权限.</p>
<p>注意:从Android4.4开始,如果只需要读写app内部的文件,则无需申明读写权限.</p>
<p>####检查是否具备读写权限<br>无论在什么地方进行外部存储操作的时候你都应该检查外部存储是否处于可用状态.</p>
<pre><code>/*Ckecks if external storage is available for read and write\*/
public boolean isExternalStorageAvailable(){
    String state = Environment.getExternalStorageState();
    return Environment.MEDIA_MOUNTED.equals();
}
</code></pre><p>通过Environment.getExternalStorageState()可以获得外部存储的状态,如连接到电脑,彻底移除,不恰当的移除等等;此时你可以通过判断外部存储的状态来决定是否需要访问外部存储的媒体文件.如下所示为外置存储的不同状态:</p>
<pre><code>public static final String MEDIA_BAD_REMOVAL = &quot;bad_removal&quot;;
public static final String MEDIA_CHECKING = &quot;checking&quot;;
public static final String MEDIA_EJECTING = &quot;ejecting&quot;;
public static final String MEDIA_MOUNTED = &quot;mounted&quot;;
public static final String MEDIA_MOUNTED_READ_ONLY = &quot;mounted_ro&quot;;
public static final String MEDIA_NOFS = &quot;nofs&quot;;
public static final String MEDIA_REMOVED = &quot;removed&quot;;
public static final String MEDIA_SHARED = &quot;shared&quot;;
public static final String MEDIA_UNKNOWN = &quot;unknown&quot;;
public static final String MEDIA_UNMOUNTABLE = &quot;unmountable&quot;;
public static final String MEDIA_UNMOUNTED = &quot;unmounted&quot;;
</code></pre><p>####保存文件共享给其他应用<br>主要是公共的多媒体库,例如MUSIC,PICTURE等等,通过以下方式获得</p>
<pre><code>Environment.getExternalPublicDirectory(String type)
</code></pre><p>其中type可分为如下几种,对应到外部存储的不同位置.</p>
<pre><code>public static String DIRECTORY_ALARMS;
public static String DIRECTORY_DCIM;
public static String DIRECTORY_DOCUMENTS;
public static String DIRECTORY_DOWNLOADS;
public static String DIRECTORY_MOVIES;
public static String DIRECTORY_MUSIC;
public static String DIRECTORY_NOTIFICATIONS;
public static String DIRECTORY_PICTURES;
public static String DIRECTORY_PODCASTS;
public static String DIRECTORY_RINGTONES;
</code></pre><p>####保存应用私有文件<br>如果你的应用有一些私有文件,如音效文件,此时可以在外部存储中创建一个私有的文件目录:</p>
<pre><code>//if you pass null as the type return the root directory
//storage/emulated/0/Android/data/packagename/
//of course you can pass non null type to create a subdirectory
Context.getExternalFilesDir(String type)    
</code></pre><p>从Android 4.4开始,读写应用的私有空间的文件并不需要读写权限,因此如果其他地方无需读写权限的情况下可以通过一下方式申明:</p>
<pre><code>&lt;manifest ...&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;
                     android:maxSdkVersion=&quot;18&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre><p>这里有个事情需要说明的是,这个应用的私有目录会随着应用的卸载而删除.同时,在媒体库中并不会显示应用的私有文件,因此,如果在你的app中属于用户的文件是不能保存到这个目录的,例如用户购买的音乐.    </p>
<p>有些手机会把内置存储划出来一部分做为外置存储使用(我们现在使用的多数都是这种方式),但是的手机还提供了SD卡卡槽.对于Android 4.3及以下的设备,通过getExternalFilesDir()只能获得内置存储中划出来的那一部分,也就是说并不能获得SD卡部分.从Android4.4开始通过getExternalFilesDir()返回的是一个数组.只有在内置存储划分的外置存储不可用或者占用满的情况下才选择使用SD卡做为应用的私有存储空间.如果想要在Android4.3及以下的设备中获取该路径则通过兼容包ContextCompact.getExternalFilesDirs()获取.</p>
<p>需要注意的是,尽管对于媒体中心(MediaStore)而言,应用外部存储的私有空间是不可见的,但是对于其他具有读取或者写入存储权限的软件而言,放在外部存储的文件是可读可写的.因此,如果你不想你的文件被别的软件使用或者更改的话,就只能放到应用的内部空间了.</p>
<p>####保存缓存文件<br>通过如下方式获得缓存文件的保存目录,缓存目录会随着应用的卸载而被删除:</p>
<pre><code>getExternalCacheDir();
</code></pre><p>跟上面提到的类似,你也可以通过ContextCompact.getExternalCacheDirs()获得SD卡之类的外置存储的缓存路径.</p>
<p>在代码开发的时候我们应该特别注意缓存文件的维护,防止缓存文件占用过多的空间.比如说我们使用一些第三方的框架的时候会让我们配置缓存空间大小.</p>
<p>##Using Databases<br>Android支持SQLite的所有功能,在应用里面创建的数据库能够被应用的任何一个类访问,但是不能在应用外访问.通常可以配合URIMatcher + ContentProvider + SQLiteOpenHelper进行数据库数据共享,列入联系人的获取.</p>
<p>##Using NetWork Connection<br>即数据存储在服务端,通过网络获取持久化数据.</p>
<p>##总结<br>前面基本上是对于官方文档的一种翻译和理解,后面来说一下自己的总结,首先观察一下现象</p>
<pre><code> ///storage/emulated/0/Android/data/com.max.testuninstall/cache
Log.d(TAG, &quot;onCreate: 外部缓存存储&quot; + this.getExternalCacheDir().toString());
//storage/emulated/0/Android/data/com.max.testuninstall/files
Log.d(TAG, &quot;onCreate: 外部私有存储&quot; + this.getExternalFilesDir(null).toString());
///storage/emulated/0
Log.d(TAG, &quot;onCreate: 外部共用存储&quot; + Environment.getExternalStorageDirectory().toString());
///data/user/0/com.max.testuninstall/cache
Log.d(TAG, &quot;onCreate: 内部缓存存储&quot; + this.getCacheDir().toString());
///data/user/0/com.max.testuninstall/files
Log.d(TAG, &quot;onCreate: 内部文件存储&quot; + this.getFilesDir().toString());
///data/user/0/com.max.testuninstall/app_null
Log.d(TAG, &quot;onCreate: 内部文件存储&quot; + this.getDir(null, MODE_PRIVATE).toString());
///data/user/0/com.max.testuninstall/app_hello_world
Log.d(TAG, &quot;onCreate: 内部文件存储&quot; + this.getDir(&quot;hello_world&quot;, MODE_PRIVATE).toString());
///data/user/0/com.max.testuninstall/files(List)
Log.d(TAG, &quot;onCreate: 内部文件存储,返回目录下所有文件&quot; + this.fileList().toString());
String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;
//data/data/packagename/files/hello_file
FileOutputStream fos = this.openFileOutput(FILENAME, Context.MODE_PRIVATE);
fos.write(string.getBytes());
fos.close();
</code></pre><p>以上对应前文所说的通过不同方式获取内部,外部文件及缓存路径.</p>
<p>###读写权限<br>Internal Storage本身无需声明任何权限即可进行读写操作.External Storage<br>从Android4.4开始读写应用私有空间无需声明读写权限,Android4.3及以下需要声明读写权限.Android系统中写入External Storage权限包含读取External Storage权限.</p>
<p>###应用卸载<br>通过上面对应的日志结合实际操作发现,Context获取的路径在应用卸载的时候会被同时删除,其实这也是可以理解的,毕竟是属于应用私有的文件.通过Environment获得的路径属于外界环境的,所以不会跟随应用的卸载而被删除掉.</p>
<p>###多用户<br>在/storage/emulated/目录下面会有 0(默认用户),如果新建一个用户则是10,再新建则是11依此类推.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天晚上Android项目组的小伙伴一起聊了一下Android数据持久化的几种方式外加一些项目中的总结吧.突然发现一些不怎么用的东西都已经快忘光了,比如说ContentProvider + LoadManger + URIMatcher + CursorAdapter,今天突然提到LoadManager感觉像是一个没接触过的东西,被小伙伴提了一下才记得有这个类的存在,更别提ContentObserver了.有点跑题了还是聊一下Android的数据持久化策略吧!&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android ADB命令大全</title>
    <link href="http://yoursite.com/2017/01/19/Android-ADB%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2017/01/19/Android-ADB命令大全/</id>
    <published>2017-01-19T08:13:13.000Z</published>
    <updated>2017-01-19T09:10:20.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>adb shell dumpsys package packagename //获取所有app的信息
adb shell ps | grep packagename //获取指定app的进程信息
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;adb shell dumpsys package packagename //获取所有app的信息
adb shell ps | grep packagename //获取指定app的进程信息
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="命令行" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Root Nexus 6 Android 7.1 官方镜像</title>
    <link href="http://yoursite.com/2017/01/19/Root-Nexus-6-Android-7-1-%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F/"/>
    <id>http://yoursite.com/2017/01/19/Root-Nexus-6-Android-7-1-官方镜像/</id>
    <published>2017-01-19T06:03:12.000Z</published>
    <updated>2017-01-19T06:31:38.000Z</updated>
    
    <content type="html"><![CDATA[<p> 本教程适用于Android7.1官方系统的Nexus 6 Root, 使用于Android 7.1.1 N6F26Q Nougat,请确保你将要root的是该设备. 原文<a href="http://www.teamandroid.com/2017/01/11/root-nexus-6-android-7-1-1-n6f26q-nougat-official-factory-image/2/" target="_blank" rel="external">地址</a>,可自行查看.<br> <a id="more"></a></p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li>本教程仅适用于安装 Android 7.1.1 (N6F26Q) 的Nexus 6设备,我自己的美版型号root正常.</li>
<li>手机需要解锁bootloader<a href="http://www.teamandroid.com/2014/12/11/unlock-bootloader-nexus-6/" target="_blank" rel="external">教程</a></li>
<li>系统必须为Android 7.1.1 N6F26Q Nougat官方镜像 <a href="http://www.teamandroid.com/2017/01/11/update-nexus-6-android-7-1-1-n6f26q-nougat-official-factory-image/" target="_blank" rel="external">教程</a></li>
</ul>
<h5 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h5><ol>
<li>下载Android SDK工具<a href="https://developer.android.com/studio/index.html#downloads" target="_blank" rel="external">地址</a>,仅获取命令行工具即可.这个地址需要翻墙</li>
<li>打开开发者选项里面的USB调试</li>
<li>下载<a href="http://www.devfiles.co/download/XYcfXURV/SuperSU-v2.78-201609011115.zip" target="_blank" rel="external">SuperSU</a></li>
<li>拷贝到手机存储空间根目录</li>
<li>下载<a href="http://www.devfiles.co/download/BWxptq2J/twrp-3.0.2-0-shamu.img" target="_blank" rel="external">TWRP</a></li>
<li><p>关机后按音量- 和 关机键进入bootloader模式,使用下载的命令行工具刷入twrp(如果没有添加命令行工具路径到环境变量则需要在放置命令行工具):</p>
<p> fastboot flash recovery twrp-3.0.2-0-shamu.img</p>
</li>
<li><p>刷入完成后,选择RECOVERY模式进入</p>
</li>
<li>选择flash zip from SD card,选中前面的SuperSU XX文件,按电源键确认刷入</li>
<li>最后选择reboot system,重启以后如果有了SuperSU这个app说明root成功了.</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本教程适用于Android7.1官方系统的Nexus 6 Root, 使用于Android 7.1.1 N6F26Q Nougat,请确保你将要root的是该设备. 原文&lt;a href=&quot;http://www.teamandroid.com/2017/01/11/root-nexus-6-android-7-1-1-n6f26q-nougat-official-factory-image/2/&quot;&gt;地址&lt;/a&gt;,可自行查看.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Root" scheme="http://yoursite.com/tags/Root/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务端更新Android SDK</title>
    <link href="http://yoursite.com/2017/01/19/Linux%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9B%B4%E6%96%B0Android-SDK/"/>
    <id>http://yoursite.com/2017/01/19/Linux服务端更新Android-SDK/</id>
    <published>2017-01-18T16:57:39.000Z</published>
    <updated>2017-01-18T17:00:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间因为新版本需求更新了一下项目的Recycleview版本,对应的SDK也更新了.项目组的几位同事的项目全都因为找不到对应的SDK报错了,后面把自己的SDK拷贝一份给他们才OK(实在想吐槽一下,我觉得做为一个Android程序员翻墙是一项基本的技能).<br><a id="more"></a><br>然而就在今天根据新的安排,后续打包统一走运维.而运维使用的是jenkins集成打包,然后上传到<a href="http://fir.im/" target="_blank" rel="external">fir</a>,测试人员直接下载安装然后进行测试.结果服务端果然出现了同样的错误.</p>
<pre><code>   Could not resolve all dependencies for configuration &apos;:app:_debugCompile&apos;.
   &gt; Could not find com.android.support:recyclerview-v7:23.4.0.
Searched in the following locations:
    https://jcenter.bintray.com/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom
    https://jcenter.bintray.com/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar
    file:/root/.jenkins/jobs_android/workspace/appbs/recyclerview-v7-23.4.0.jar
    file:/root/.jenkins/jobs_android/workspace/appbs/recyclerview-v7.jar
    file:/usr/local/android/extras/android/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom
    file:/usr/local/android/extras/android/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar
    file:/usr/local/android/extras/google/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom
    file:/usr/local/android/extras/google/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar
Required by:
    workspace:app:unspecified
    workspace:app:unspecified &gt; com.yanzhenjie:recyclerview-swipe:1.0.1
    &gt; Could not find com.android.support:recyclerview-v7:23.4.0.
Searched in the following locations:
    https://jcenter.bintray.com/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom
    https://jcenter.bintray.com/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar
    file:/root/.jenkins/jobs_android/workspace/appbs/recyclerview-v7-23.4.0.jar
    file:/root/.jenkins/jobs_android/workspace/appbs/recyclerview-v7.jar
    file:/usr/local/android/extras/android/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom
    file:/usr/local/android/extras/android/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar
    file:/usr/local/android/extras/google/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom
    file:/usr/local/android/extras/google/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar
Required by:
    workspace:app:unspecified &gt; com.android.support:design:23.1.1
</code></pre><p>然后我就跟运维的胖哥搜索教程,第一步去Github上面下载了<a href="https://github.com/getlantern/lantern" target="_blank" rel="external">lantern</a> (Lantern都有付费版本了),然后去谷歌搜索Linux update Android SDK,然后找到了官方的<a href="http://tools.android.com/recent/updatingsdkfromcommand-line" target="_blank" rel="external">教程</a>,在GFW的帮助下,并没有什么用.<img src="http://tools.android.com/recent/updatingsdkfromcommand-line/2011-08-19%20tools%20screenshot%20r12%20install%20no-ui%20b.png?attredirects=0" alt="Official Guidance"></p>
<p>第二步,想在运维那里直接使用云梯翻墙更新(这里吐槽一下,云梯实在很不稳定,建议自己买VPS+Shadowsocks才是王道).跟预料的一样,根本连不上.</p>
<p>第三步,其实一开始思路就是错的,用什么谷歌搜索,只有少数的被国家保护的公民才有这种问题啊,所以直接使用百度搜索即可.果然还是自家人懂得自家事,找到了很多<a href="https://segmentfault.com/a/1190000004639481" target="_blank" rel="external">内容</a>.</p>
<pre><code>//step 0:cd 到你安装SDK目录的Tools目录下(例如:/Volumes/work/sdk/tools)

//step 1:设置代理获取可更新列表
./android list sdk --extended --proxy-host android-mirror.bugly.qq.com --proxy-port 8080 -s

//step 2:设置更新代理并选择下载文件,我这里选择的所有 -a
./android update sdk --proxy-host android-mirror.bugly.qq.com --proxy-port 8080 -s -u -a        


//当然你也可以自定义参数
 Updates the SDK by suggesting new platforms to install if available.
Options:
  -f --force     : Forces replacement of a package or its parts, even if
                   something has been modified.
  -n --dry-mode  : Simulates the update but does not download or install
                   anything.
     --proxy-host: HTTP/HTTPS proxy host (overrides settings if defined)
  -s --no-https  : Uses HTTP instead of HTTPS (the default) for downloads.
  -t --filter    : A filter that limits the update to the specified types of
                   packages in the form of a comma-separated list of
                   [platform, system-image, tool, platform-tool, doc, sample,
                   source]. This also accepts the identifiers returned by
                   &apos;list sdk --extended&apos;.
  -u --no-ui     : Updates from command-line (does not display the GUI)
     --proxy-port: HTTP/HTTPS proxy port (overrides settings if defined)
  -p --obsolete  : Deprecated. Please use --all instead.
  -a --all       : Includes all packages (such as obsolete and non-dependent
                   ones.)



//step 3:同意license内容,反正你也没的选,然后就会自动下载并解压
Do you accept the license &apos;android-sdk-preview-license-52d11cd2&apos; [y/n]:
</code></pre><p>这里代理服务器其实蛮多的,参考<a href="http://www.androiddevtools.cn/" target="_blank" rel="external">AndroidDev</a>,不懂翻墙人士的福音.深圳地区设置腾讯代理以后下载速度基本上都是2-3M起,速度非常快.</p>
<p><strong>使用上面命令行是因为Linux Server没有可用图形操作界面,如果有图形操作界面的话还是不要使用这种方式了</strong>,把时间花在更有用的地方吧!毕竟我们是一群需求没定好就能把项目做完的码农!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间因为新版本需求更新了一下项目的Recycleview版本,对应的SDK也更新了.项目组的几位同事的项目全都因为找不到对应的SDK报错了,后面把自己的SDK拷贝一份给他们才OK(实在想吐槽一下,我觉得做为一个Android程序员翻墙是一项基本的技能).&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="自动构建" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Android拷贝文件Buff Size最佳实践</title>
    <link href="http://yoursite.com/2017/01/18/Android%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6Buff-Size%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/01/18/Android拷贝文件Buff-Size最佳实践/</id>
    <published>2017-01-18T14:25:42.000Z</published>
    <updated>2017-01-18T16:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为在我们的项目里面有一个大小超过11M的assets<a href="http://stackoverflow.com/questions/5583487/hosting-an-executable-within-android-application" target="_blank" rel="external">可执行文件</a>,所以在app初次安装或者版本升级的时候需要全新拷贝或者升级拷贝.在实际使用中发现在app覆盖安装的时候重新拷贝assets文件很容易出现拷贝不完整的问题,这会导致这个可执行文件运行出现错误,最直观的表现就是界面数据展示异常,且只能通过卸载重装或者清除数据重新生成这个可执行文件解决异常,所以后来我就进行了一些优化.<br><a id="more"></a></p>
<h5 id="1-加入文件完整性校验"><a href="#1-加入文件完整性校验" class="headerlink" title="1.加入文件完整性校验"></a>1.加入文件完整性校验</h5><p>最开始的时候首先想到的是对文件进行完整性校验,即通过文件的MD5值进行对比,观察生成的完整的可执行文件的MD5值是否发生了改变来进行判断.如果MD5值出现改变则提示用户初始化失败,强制关闭app并且重新生成可执行文件.这里有一点补充的是之所以有这个分割成1M文件是因为<strong>在Android2.3之前单个assets文件大小不能超过1M</strong>,<a href="http://ponystyle.com/blog/2010/03/26/dealing-with-asset-compression-in-android-apps/" target="_blank" rel="external">参考资料</a>看这里. 拷贝代码例子如下,当然在我们的项目中还应该有一个分割和合并的过程,具体的代码就不再这里详细的写出来了: </p>
<pre><code>File Path = Ctxt.getDir(&quot;Data&quot;, 0);
File DBFile = new File(Path, &quot;database.db&quot;);

if(!DBFile.exists() || DatabaseNeedsUpgrade)  //Need to copy...
    CopyDatabase(Ctxt, DBFile);


static private void CopyDatabase(Context Ctxt, File DBFile) throws IOException
{
    AssetManager assets = Ctxt.getAssets();
    OutputStream outstream = new FileOutputStream(DBFile);
    DBFile.createNewFile();
    byte []b = new byte[1024];
    int i, r;
    String []assetfiles = assets.list(&quot;&quot;);
    Arrays.sort(assetfiles);
    for(i=1;i&lt;10;i++) //I have definitely less than 10 files; you might have more
    {
        String partname = String.format(&quot;%d.db&quot;, i);
        if(Arrays.binarySearch(assetfiles, partname) &lt; 0) //No such file in assets - time to quit the loop
            break;
        InputStream instream = assets.open(partname);
        while((r = instream.read(b)) != -1)
            outstream.write(b, 0, r);
        instream.close();
    }
    outstream.close();
}
</code></pre><h5 id="2-考虑不分割文件"><a href="#2-考虑不分割文件" class="headerlink" title="2.考虑不分割文件"></a>2.考虑不分割文件</h5><p>前面有提到其实只有在Android2.3之前才有assets单个文件大小不能超过1M的限制,而拷贝过程通常都是在进行到其中的某个文件时就失败了,所以考虑不分割文件直接进行拷贝.在实际测试中发现并没有什么大的改善,甚至于拷贝速度还下降了.</p>
<h5 id="3-从拷贝的过程入手"><a href="#3-从拷贝的过程入手" class="headerlink" title="3.从拷贝的过程入手"></a>3.从拷贝的过程入手</h5><p>通常我们拷贝文件的时候都会使用int数组进行缓存加速拷贝过程,但是这个缓存的大小究竟要设置为多大比较合适可能大家都没怎么想过.正常来说在设备允许的情况下当然是越大越好,但实际使用过程中,我们也要考虑增大缓存带来的收益.通过测试和查阅<a href="http://stackoverflow.com/questions/10143731/android-optimal-buffer-size" target="_blank" rel="external">资料</a>发现,在使用32K缓存大小的情况下收益是最好的.大幅度的提升了拷贝速度,后面我们基本上没有遇到过由于文件拷贝不完整导致的启动异常问题.如下表所示,对应不同缓存拷贝20M文件的耗时:</p>
<pre><code>               128     256     512     1K      2K      4K      8K      16K     32K     64K     128K    256K    512K    1M      2M      4M      8M      16M
Galaxy S       4047    3060    269     155     100     65      64      52      51      45      47      50      49      43      44      46      45      58
Optimus LTE    1178    617     322     172     101     65      47      42      41      35      36      39      44      61      56      51      72      60
HTC EVO        3971    1884    941     480     251     141     95      69      56      50      48      55      50      49      48      48      48      47         
Galaxy S2      750     383     210     123     74      50      41      37      35      34      34      37      39      44      46      44      45      44
Galaxy Nexus   2272    1216    659     341     187     108     70      52      41      38      38      45      44      54      56      66      68      58
Galaxy Note    1549    799     404     220     127     75      58      54      52      56      52      45      44      62      43      39      44      46
</code></pre><p>可以发现,32K缓存拷贝文件的收益是极高的,对手机内存的压力也比较小.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为在我们的项目里面有一个大小超过11M的assets&lt;a href=&quot;http://stackoverflow.com/questions/5583487/hosting-an-executable-within-android-application&quot;&gt;可执行文件&lt;/a&gt;,所以在app初次安装或者版本升级的时候需要全新拷贝或者升级拷贝.在实际使用中发现在app覆盖安装的时候重新拷贝assets文件很容易出现拷贝不完整的问题,这会导致这个可执行文件运行出现错误,最直观的表现就是界面数据展示异常,且只能通过卸载重装或者清除数据重新生成这个可执行文件解决异常,所以后来我就进行了一些优化.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>搭建跨平台go编译环境</title>
    <link href="http://yoursite.com/2017/01/18/%E6%90%AD%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0go%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2017/01/18/搭建跨平台go编译环境/</id>
    <published>2017-01-18T12:12:15.000Z</published>
    <updated>2017-01-18T12:30:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是为了搭建golang跨平台环境,从而实现一套golang代码运行在多重环境(OSX,Linux,Android,iOS,Windows),实现跨平台共享代码,简化开发流程.</p>
<ol>
<li>安装Docker   </li>
<li>安装golang</li>
<li>安装xgo镜像及编译指令</li>
<li>配置环境变量</li>
</ol>
<a id="more"></a>
<h4 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. 安装docker</h4><p>针对Mac和Windows可以直接下载安装包进行安装,其他系统可以使用命令行进行安装.<a href="https://www.docker.com/products/docker#/mac" target="_blank" rel="external">参考链接</a>,最后通过docker version 指令进行查看</p>
<pre><code># Jacen at EveeedeMacBook-Pro.local in ~ [10:51:52] docker version
Client:
Version:      1.12.5
API version:  1.24
Go version:   go1.6.4
Git commit:   7392c3b
Built:        Fri Dec 16 06:14:34 2016
OS/Arch:      darwin/amd64

Server:
Version:      1.12.5
API version:  1.24
Go version:   go1.6.4
Git commit:   7392c3b
Built:        Fri Dec 16 06:14:34 2016
OS/Arch:      linux/amd64
</code></pre><h4 id="2-安装golang"><a href="#2-安装golang" class="headerlink" title="2. 安装golang"></a>2. 安装golang</h4><p>同样的在Windows和Mac下面都有一键安装包,针对其他系统也是通过命令行进行安装.<a href="https://golang.org/dl/" target="_blank" rel="external">参考链接</a>,安装好以后还需要进行环境变量的配置.</p>
<p>在mac系统和Linux系统下面,Windows配置环境变量</p>
<pre><code>export GOROOT=&quot;/usr/local/go&quot;
export GOPATH=&quot;你的工作目录&quot;  //这里主要是影响到后面需要安装的xgo
</code></pre><p>再执行go env查看是否配置成功:</p>
<pre><code>GOARCH=&quot;amd64&quot;
GOBIN=&quot;&quot;
GOEXE=&quot;&quot;
GOHOSTARCH=&quot;amd64&quot;
GOHOSTOS=&quot;darwin&quot;
GOOS=&quot;darwin&quot;
GOPATH=&quot;/Volumes/Work/go&quot;
GORACE=&quot;&quot;
GOROOT=&quot;/usr/local/go&quot;
GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;
CC=&quot;clang&quot;
GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/w4/75xgx41n2bb7mm3m0dxbp0d40000gn/T/go-build003828011=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;
CXX=&quot;clang++&quot;
CGO_ENABLED=&quot;1&quot;
</code></pre><h4 id="3-安装xgo-docker镜像"><a href="#3-安装xgo-docker镜像" class="headerlink" title="3. 安装xgo docker镜像"></a>3. 安装xgo docker镜像</h4><p>xgo的docker镜像是我们真正的编译环境,<a href="https://github.com/karalabe/xgo" target="_blank" rel="external">Github地址</a></p>
<ol>
<li><p>安装xgo docker镜像,这个镜像大概4.xG,需要花较长的时间下载</p>
<p> docker pull karalabe/xgo-latest </p>
</li>
</ol>
<p>这里latest指的最新的编译环境,如果需要的话也可以指定安装具体版本的镜像,<a href="https://hub.docker.com/u/karalabe/" target="_blank" rel="external">在这里</a>,这个版本的差异主要是golang版本的不同,由于编译的时候可以指定golang版本进行编译,所以我们直接安装最新版本即可.</p>
<ol>
<li><p>安装xgo </p>
<p> go get github.com/karalabe/xgo</p>
</li>
</ol>
<p>安装xgo编译工具,这个工具封装了go build,简化了我们的操作.</p>
<h4 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4. 配置环境变量"></a>4. 配置环境变量</h4><p>如果我们使用的是bash的话可以将环境变量配置到.bash_profile中,免去export的过程</p>
<h5 id="使用bash"><a href="#使用bash" class="headerlink" title="使用bash"></a>使用bash</h5><ol>
<li><p>在 ~ 目录下编辑.bash_profile 文件,在末尾添加</p>
<p> export GOPATH=”你的工作目录”<br> export GOROOT=”usr/local/go”<br> export PATH=$PATH:$GOPATH/bin<br> export GOROOT_BOOTSTRAP=$GOROOT</p>
</li>
<li>source .bash_profile使得配置文件生效</li>
</ol>
<h5 id="使用如zsh-shell程序"><a href="#使用如zsh-shell程序" class="headerlink" title="使用如zsh shell程序"></a>使用如zsh shell程序</h5><ol>
<li>在~ 目录下编辑.zshrc 文件,添加上面同样的文件</li>
<li>同上source生效</li>
</ol>
<h4 id="5-测试xgo交叉编译环境是否OK"><a href="#5-测试xgo交叉编译环境是否OK" class="headerlink" title="5. 测试xgo交叉编译环境是否OK"></a>5. 测试xgo交叉编译环境是否OK</h4><pre><code>$ cd $GOPATH/src       // If you have multiple (I have at least 3 in there), change into any, doesn&apos;t matter
$ mkdir xgo_test
$ cd xgo_test
$ echo -e &apos;package main\n import &quot;fmt&quot;\n func main(){\nfmt.Println(&quot;Hello&quot;)\n}&apos; &gt; main.go
$ xgo .
</code></pre><p>执行完上述命令后在当前目录查看是否有编译生成的可执行文件</p>
<h4 id="6-打包"><a href="#6-打包" class="headerlink" title="6. 打包"></a>6. 打包</h4><pre><code>  ~ xgo  /Volumes/Public\ Storage/go/src/zhjd()
  ~ xgo --targets=android-14/arm /Volumes/Storage/go/src/zhjd 指定生成Android端专用的会快很多很多,这里的14指的是最小支持SDK版本
Checking docker installation...
Client:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 23:26:11 2016
 OS/Arch:      darwin/amd64

Server:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 23:26:11 2016
 OS/Arch:      linux/amd64

Checking for required docker image karalabe/xgo-latest... found.
Cross compiling zhjd...
Building locally zhjd...
Assembling toolchain for android-16/arm...
Bootstrapping android-16/arm...
Compiling for android-16/arm...
Assembling toolchain for android-16/386...
Bootstrapping android-16/386...
Compiling for android-16/386...
No API C header specified, skipping android-16/aar... 重点关注
Compiling for linux/amd64...
Compiling for linux/386...
Bootstrapping linux/arm-5...
Compiling for linux/arm-5...
Cleaning up Go runtime for linux/arm-5...
Bootstrapping linux/arm-6...
Compiling for linux/arm-6...
Cleaning up Go runtime for linux/arm-6...
Bootstrapping linux/arm-7...
Compiling for linux/arm-7...
Cleaning up Go runtime for linux/arm-7...
Compiling for linux/arm64...
Compiling for linux/mips64...
Compiling for linux/mips64le...
Compiling for windows-4.0/amd64...
Compiling for windows-4.0/386...
Compiling for darwin-10.6/amd64...
Compiling for darwin-10.6/386...
Bootstrapping ios-5.0/arm-7...
# runtime/cgo
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
# net
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
# os/user
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
Compiling for ios-5.0/arm-7...
# github.com/mattn/go-sqlite3
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
# github.com/mattn/go-sqlite3
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
Cleaning up Go runtime for ios-5.0/arm-7...
Bootstrapping ios-5.0/arm64...
# runtime/cgo
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
# net
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
# os/user
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
Compiling for ios-5.0/arm64...
# github.com/mattn/go-sqlite3
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
# github.com/mattn/go-sqlite3
ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE
Cleaning up Go runtime for ios-5.0/arm64...
Cleaning up build environment...
</code></pre><p>查看编译生成的文件</p>
<pre><code>➜  all ls -al
total 427872
drwxr-xr-x  21 silence  staff       714 Dec 29 11:37 .
drwxr-xr-x+ 29 silence  staff       986 Dec 29 11:37 ..
-rw-r--r--@  1 silence  staff      6148 Dec 29 11:37 .DS_Store
-rwxr-xr-x   1 silence  staff  14633608 Dec 29 11:27 zhjd-android-16-386
drwxr-xr-x   5 silence  staff       170 Dec 29 11:27 zhjd-android-16-aar
-rwxr-xr-x   1 silence  staff  14705872 Dec 29 11:26 zhjd-android-16-arm
-rwxr-xr-x   1 silence  staff  10418780 Dec 29 11:32 zhjd-darwin-10.6-386
-rwxr-xr-x   1 silence  staff  11578172 Dec 29 11:31 zhjd-darwin-10.6-amd64
-rwxr-xr-x   1 silence  staff  11224720 Dec 29 11:34 zhjd-ios-5.0-arm64
-rwxr-xr-x   1 silence  staff  10569184 Dec 29 11:33 zhjd-ios-5.0-armv7
drwxrwxrwx   3 silence  staff       102 Dec 29 11:35 zhjd-ios-5.0-framework
-rwxr-xr-x   1 silence  staff  14611432 Dec 29 11:28 zhjd-linux-386
-rwxr-xr-x   1 silence  staff  17246480 Dec 29 11:27 zhjd-linux-amd64
-rwxr-xr-x   1 silence  staff  13034956 Dec 29 11:28 zhjd-linux-arm-5
-rwxr-xr-x   1 silence  staff  12965808 Dec 29 11:29 zhjd-linux-arm-6
-rwxr-xr-x   1 silence  staff  12939788 Dec 29 11:29 zhjd-linux-arm-7
-rwxr-xr-x   1 silence  staff  17075720 Dec 29 11:29 zhjd-linux-arm64
-rwxr-xr-x   1 silence  staff  18700376 Dec 29 11:30 zhjd-linux-mips64
-rwxr-xr-x   1 silence  staff  18699640 Dec 29 11:31 zhjd-linux-mips64le
-rwxr-xr-x   1 silence  staff   9734407 Dec 29 11:31 zhjd-windows-4.0-386.exe
-rwxr-xr-x   1 silence  staff  10889885 Dec 29 11:31 zhjd-windows-4.0-amd64.exe
</code></pre><p>可以发现,针对不同平台生成了不同类型的文件.Android支持生成aar库文件,iOS支持生成Framework库文件</p>
<h3 id="平台实测"><a href="#平台实测" class="headerlink" title="平台实测"></a>平台实测</h3><h4 id="Android端测试"><a href="#Android端测试" class="headerlink" title="Android端测试"></a>Android端测试</h4><ol>
<li><p>推送到设备中,之所以不直接推送到app目录下是因为权限问题,这里如果提示adb命令不存在同样的也要把Android SDK中的adb命令配置到环境变量中</p>
<pre><code>//直接推送到app目录下会有权限问题

adb push zhjd-android-16-arm data/data/com,kingdee.zhihuiji 
adb: error: failed to copy &apos;zhjd-android-16-arm&apos; to &apos;data/data/    com.kingdee.zhihuiji&apos;: Permission denied

//所以推送到该目录下

adb push zhjd-android-16-arm data/local/tmp                
[100%] data/local/tmp/zhjd-android-16-arm
</code></pre></li>
</ol>
<ol>
<li>切换到Android设备并执行该文件,这里只能使用已经<strong>root的设备</strong></li>
</ol>
<pre><code>adb shell 进入手机命令行
su 切换超级用户
cd /data/local/tmp 
./zhjd-android-16-arm
</code></pre><p>最后在终端会输出可执行文件的执行结果</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是为了搭建golang跨平台环境,从而实现一套golang代码运行在多重环境(OSX,Linux,Android,iOS,Windows),实现跨平台共享代码,简化开发流程.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装Docker   &lt;/li&gt;
&lt;li&gt;安装golang&lt;/li&gt;
&lt;li&gt;安装xgo镜像及编译指令&lt;/li&gt;
&lt;li&gt;配置环境变量&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="CrossCompile" scheme="http://yoursite.com/tags/CrossCompile/"/>
    
  </entry>
  
  <entry>
    <title>Android Library中的R文件不是常量</title>
    <link href="http://yoursite.com/2017/01/18/Android-Library%E4%B8%AD%E7%9A%84R%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/01/18/Android-Library中的R文件/</id>
    <published>2017-01-18T11:59:40.000Z</published>
    <updated>2017-01-18T12:02:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间跟项目老大提了个请求,就是将<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">Butterknife</a>加入到我们的项目中,结合<a href="https://github.com/avast/android-butterknife-zelezny" target="_blank" rel="external">android-butterknife-zelezny</a>使用,这样子不仅代码简洁,也可以减少一些findViewById的繁琐过程,提升我们的开发效率.效果如下图,是不是特别简洁.</p>
<p><img src="https://github.com/avast/android-butterknife-zelezny/raw/master/img/zelezny_animated.gif" alt="MacDown Screenshot"><br><a id="more"></a><br>经过老大的同意以后,我开始加依赖,下载自动注解插件,进行自动生成代码,一气呵成,神清气爽.But问题立马就暴露出来了,代码如下:</p>
<pre><code>  @OnClick({R2.id.m_button_pattern, R2.id.m_button_password})
      public void onClick(View view) {
    Log.d(&quot;xx&quot;, &quot;========onClick=========&quot;);
    Intent intent = new Intent();
    switch (view.getId()) {
        case R2.id.m_button_pattern:
            intent.setClass(getApplicationContext(),MainActivity.class);
            Log.d(&quot;xx&quot;, &quot;========onClick====MainActivity=====&quot;);
            break;
        case R2.id.m_button_password:
            intent.setClass(getApplicationContext(),SetPasswordLockActivity.class);
            Log.d(&quot;xx&quot;, &quot;========onClick=====SetPasswordLockActivity====&quot;);
            break;
    }
    this.startActivity(intent);
}
</code></pre><p>然后问题就出现了.由于我们的项目是在Library中开发(蛋疼得不行,很多限制),问题就是出在这里,请看下面的代码:</p>
<pre><code>//Library中生成的R文件
public static int activity_open_exit=0x7f04000d;
//Module中生成的R文件
public static final int abc_fade_out=0x7f050001;
</code></pre><p>所以在Library中无法使用switch语句进而影响到了Butterknife的使用.</p>
<p>至于为什么在Library中无法使用参考<a href="http://tools.android.com/tips/non-constant-fields" target="_blank" rel="external">谷歌文档</a>.经过阅读我们知道从ADT14开始Library中的R文件才从静态常量变为非常量.因为如果在多个Library中可能出现id冲突的问题.在ADT14以前则采用的是将所有的资源文件和相关的代码重新随着主项目一起重新编译,导致编译速度过慢.因此,从ADT14开始就变成了非常量的id了:</p>
<pre><code>int id = view.getId();
switch (id) {
    case R.id.button1:
        action1();
        break;
    case R.id.button2:
        action2();
        break;
    case R.id.button3:
        action3();
        break;
}
</code></pre><p>Android Studio也提供了一键转换的快捷方式如下图:</p>
<p><img src="http://tools.android.com/_/rsrc/1319062860174/tips/non-constant-fields/convert2.png" alt="ConvertSwitch"></p>
<p>然后就变成了如下所示的代码了.</p>
<pre><code>int id = view.getId();
if (id == R.id.button1) {
    action1();
} else if (id == R.id.button2) {
    action2();
} else if (id == R.id.button3) {
    action3();
}
</code></pre><p> 因为找资料的原因又去看了下Github的Butterknife, JakeWharton大神终于在大家的强烈请求下更新了支持Library, <a href="https://github.com/JakeWharton/butterknife/blob/master/CHANGELOG.md" target="_blank" rel="external">更新日志</a>;</p>
<pre><code>Version 8.2.0 (2016-07-10)

New: Support for library projects. Requires application of a Butter Knife Gradle plugin. See README for details.
New: Generated code now emits R references instead of raw integer IDs.
Fix: @OnPageChange listener binding now uses the &apos;add&apos;/&apos;remove&apos; methods on ViewPager instead of &apos;set&apos;.
</code></pre><p>算是意料之外的惊喜吧,下周一就把Butterknife加入我们的项目!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间跟项目老大提了个请求,就是将&lt;a href=&quot;https://github.com/JakeWharton/butterknife&quot;&gt;Butterknife&lt;/a&gt;加入到我们的项目中,结合&lt;a href=&quot;https://github.com/avast/android-butterknife-zelezny&quot;&gt;android-butterknife-zelezny&lt;/a&gt;使用,这样子不仅代码简洁,也可以减少一些findViewById的繁琐过程,提升我们的开发效率.效果如下图,是不是特别简洁.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/avast/android-butterknife-zelezny/raw/master/img/zelezny_animated.gif&quot; alt=&quot;MacDown Screenshot&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建gomobile开发环境</title>
    <link href="http://yoursite.com/2017/01/18/%E6%90%AD%E5%BB%BAgomobile%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2017/01/18/搭建gomobile开发环境/</id>
    <published>2017-01-18T07:24:21.000Z</published>
    <updated>2017-01-18T12:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>gomobile是谷歌开发的一种跨平台技术解决方案,可以针对iOS和Android平台进行直接开发或者进行Library开发.<br><a id="more"></a></p>
<h3 id="配置gomobile开发环境"><a href="#配置gomobile开发环境" class="headerlink" title="配置gomobile开发环境"></a>配置gomobile开发环境</h3><ol>
<li>设置终端http,https代理</li>
<li>配置git,及环境变量</li>
<li>配置golang及gopath环境及环境变量</li>
<li>配置gomobile及环境变量</li>
</ol>
<h3 id="gomobile的优缺点"><a href="#gomobile的优缺点" class="headerlink" title="gomobile的优缺点"></a>gomobile的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>直接构建用于ios的framework文件,可以直接调用生成的类</li>
<li>直接构建用于Android的aar文件,使用jni直接调用</li>
<li>统一三端规则,避免重复开发和一些错误</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><h5 id="数据类型限制"><a href="#数据类型限制" class="headerlink" title="数据类型限制"></a>数据类型限制</h5><ul>
<li>int and float;</li>
<li>string and boolean;</li>
<li>byte[]. The current implementation doesn’t allow to use []byte as the     function argument (<a href="https://golang.org/issues/12113" target="_blank" rel="external">https://golang.org/issues/12113</a>);</li>
<li>function has to return only supported types, it may not return the result, it may return one or two types wherein the second type should be an error;</li>
<li>interfaces could be used if they are exported to files of any supported type;</li>
<li>struct type, only in case all fields meet the constraints.</li>
</ul>
<p>]</p>
<h3 id="环境搭建流程"><a href="#环境搭建流程" class="headerlink" title="环境搭建流程"></a>环境搭建流程</h3><h4 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a>官方教程</h4><ol>
<li><a href="https://godoc.org/golang.org/x/mobile/cmd/gomobile" target="_blank" rel="external">官网地址</a>,安装gomobile,当然首先得安装golang才能够使用go命令</li>
</ol>
<pre><code>$ go get golang.org/x/mobile/cmd/gomobile
$ gomobile init
//然后就可以通过gomobile指令查看了
$ gomobile
</code></pre><ol>
<li>前面地址进不去的话有个<a href="https://github.com/golang/mobile" target="_blank" rel="external">Github地址</a></li>
</ol>
<h4 id="使用Github镜像安装"><a href="#使用Github镜像安装" class="headerlink" title="使用Github镜像安装"></a>使用Github镜像安装</h4><p>由于使用谷歌的官网资源需要在命令行翻墙,比较麻烦,所以直接使用Github的镜像进行安装.</p>
<pre><code>$ mkdir -p $GOPATH/src/github.com/golang
$ cd $GOPATH/src/github.com/golang
$ git clone https://github.com/golang/mobile.git
$ mkdir -p $GOPATH/src/golang.org/x    
$ cp -r $GOPATH/src/github.com/golang/mobile $GOPATH/src/golang.org/x 
$ cd $GOPATH/src/golang.org/x/mobile/cmd/gomobile
$ go install  //会在$GOPATH/src/bin 目录下生成gomobile  
$ gomobile init //安装NDK之类的
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gomobile是谷歌开发的一种跨平台技术解决方案,可以针对iOS和Android平台进行直接开发或者进行Library开发.&lt;br&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>常用的hexo指令</title>
    <link href="http://yoursite.com/2017/01/18/%E5%B8%B8%E7%94%A8%E7%9A%84hexo%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/01/18/常用的hexo指令/</id>
    <published>2017-01-18T06:15:47.000Z</published>
    <updated>2017-01-18T08:12:23.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>hexo new post &quot;article title&quot;  //创建新的post,创建目录为: /source/_posts/
hexo d  //deploy 发布
hexo s //
hexo clean
hexo s --debug


hexo new page categories
hexo new page about
hexo new page commonweal
hexo new page sitemap
hexo new page tags
hexo new page archives
hexo new page tags
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;hexo new post &amp;quot;article title&amp;quot;  //创建新的post,创建目录为: /source/_posts/
hexo d  //deploy 发布
hexo s //
hexo clean
hexo s --debu
    
    </summary>
    
      <category term="博客编写" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac OS X 配置环境变量</title>
    <link href="http://yoursite.com/2017/01/16/article-title/"/>
    <id>http://yoursite.com/2017/01/16/article-title/</id>
    <published>2017-01-16T14:15:59.000Z</published>
    <updated>2017-01-18T12:03:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>/etc/bashrc 是针对系统所有用户的全局变量，只有root用户才能修改这两个文件，对一般用户来说是他们是只读的。一般用户要想修改它们，可以在命令前加sudo，意思是以Root身份执行，比如：sudo vi /etc/profile  ，然后按照提示输入密码即可。(以上是针对使用默认shell的用户,如果使用zsh的话则对应的修改文件是.zshrc)</p>
<p>因此，对于一般用户而言，通常我们建议去修改~/.bash_profile来设置环境变量，它是用户级的设置，只对当前用户有效。<br>操作步骤:</p>
<pre><code>1、打开Terminal（终端）
2、输入：vi ~/.bash_profile
3、设置PATH：export PATH=/usr/local/mysql/bin:$PATH
4、输入：:wq    //保存并退出vi
5、修改立即生效：source ~/.bash_profile
6、查看环境变量的值：echo $PATH
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;/etc/bashrc 是针对系统所有用户的全局变量，只有root用户才能修改这两个文件，对一般用户来说是他们是只读的。一般用户要想修改它们，可以在命令前加sudo，意思是以Root身份执行，比如：sudo vi /etc/profile  ，然后按照提示输入密码即可。(以
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/01/16/hello-world/"/>
    <id>http://yoursite.com/2017/01/16/hello-world/</id>
    <published>2017-01-16T14:11:26.000Z</published>
    <updated>2017-01-18T06:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
