<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java-深入理解Java虚拟机-线程安全与锁优化]]></title>
    <url>%2F2019%2F03%2F18%2Fjava-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[13.2 线程安全当多个线程访问 一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其它的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。这是Java Concurrency In Practice一书中作者Brian Goetz对“线程安全”的定义。 13.2.1 Java语言中的线程安全按照线程安全的“安全程度”由强至弱来排序，可以讲Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 1.不可变 在Java API中符合不可变要求的类型，有String类型，final修饰的基本变量，final修饰属性的对象，枚举类，以及java.lang.Number的部分子类，如Long，Double，BigInteger，BigDecimal（其中AtomicInteger和AtomicLong并非是不可变的） 2.绝对线程安全 一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。例如Vector的get()、remove()和size()方法都是同步的，但是在多线程的环境下，如果不在方法调用端坐额外的同步措施的话，使用这段代码仍然是不安全的。因为如果另一个线程恰好在错误的时间里删除了一个元素，当前线程去访问的话会出现ArrayIndexOutOfBoundsException 3.相对线程安全 相对线程安全就是我们通常意义上所讲的线程安全，它需要保证这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。 在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collection的synchronizedCollection()方法包装的集合等。 4.线程兼容 线程兼容是指对象本身并不是线程安全的，但是可以通过调用端正确地使用同步手段来保证对象在并发环境下的安全使用。 Java API中大部分的类都是属于线程兼容的。 5.线程对立 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。这种现象是少见的，有害的，应当尽量避免。 一个线程对立的例子就是Thread类的suspend()和resume()方法，如果两个线程同时持有一个对象，一个尝试去中断线程，另一个尝试去恢复线程，并发时，无论是否采取了同步措施，都有可能死锁。常见的线程对立操作还有System.setIn()、System.setOut()和System.runFinalizersOnExit()等。 13.2.2 线程安全的实现方法1.互斥同步（MutualExclusion&amp;Synchronization） 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方法。因此，互斥是因，同步是果；互斥是方法，同步是目的。 Java中，最常见的互斥同步方式是使用synchronized关键字，synchronized关键字编译生成字节码后会在同步块前后分别生成monitorenter和monitorexit两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。在Java编程中，如果明确指定了synchronized的对象参数，那就是这个对象的reference；如果没有明确指定，就根据synchronized修饰的是实例方法还是类方法，去取相应的对象实例或Class对象来做为锁对象。 monitorenter时锁计数器加1，monitoexit时锁计数器减1，计数器为0是锁被释放。如果获取对象锁失败，则当前线程阻塞等待，直到另一个线程释放对象锁。 在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点需要特别注意： 同步块对同一条线程时可重入的，不会出现锁死的问题。 同步块在已进入的线程释放对象锁之前，会阻塞其它线程的进入。 由于Java的线程都是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，需要从用户态切换到核心态，这是一个比较重的操作。 除了synchronized之外，还可以通过java.util.concurrent包中的重入锁（ReentrantLock）来实现同步，两者基本使用方式一致，只是在代码写法上有点区别，一个表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块完成），另一个表现为原生语法层面的互斥锁。相比synchronized，ReentrantLock增加了多项高级功能，主要有如下3个： 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的锁可以放弃等待改为处理其它事情。 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。可以通过构造参数控制是否使用公平锁。Synchronized是非公平的，抢占式的。 锁绑定多个条件：一个ReentrantLock对象可以绑定多个Condition对象。Synchronized只能绑定一个条件。 不过从jdk1.6开始，虚拟机对synchronized优化较多，所以synchronized更适合我们的使用。 2.非阻塞同步 互斥同步最主要的问题就是进行线程阻塞和唤醒锁带来的性能问题，这种方式称为阻塞同步（Blocking Synchronization）。互斥同步是一种悲观锁，无论共享数据是否真的会出现竞争，都要进行加锁（这里说的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态装换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 随着硬件指令集的发展，出现了一种基于冲突检测的乐观并发策略。通俗来说，就是先进行操作，等到检测到冲突再采取补偿措施（常见的补偿措施就是不断重试，直到成功），这种同步方式称为非阻塞同步（Non-Blocking Synchronization）。 乐观并发策略需要“硬件指令集的发展”的原因是，我们需要操作和冲突检测这两个步骤具有原子性。硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有： 测试并设置（Test-and-Set） 获取并增加（Fetch-and-Increment） 交换（Swap） 比较并交换（Compare-and-Swap，下文称为CAS） 加载链接/条件存储（Load-Linked/Store-Conditionl，下文称LL/SC） 前三条时20世纪就存在于大多数指令集之中的处理器指令，后面两条时现代处理器新增的。 CAS指令需要三个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预估值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值更新V的值，否则就不执行更新，但是都回返回V的旧值，上述操作时是一个原子过程。 在Java中使用CAS编译出来的结果是一条与平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联（别虚拟机特殊处理的方法称为固有函数（Intrinsics），类似的还有Math.sin()方法等）进去了。 CAS还存在一个逻辑漏洞，如果V初次读取的时候是A值，准备赋值的时候还是A值，但是它有可能被多次修改最终改为A值，这个漏洞称为CAS操作的“ABA”问题。一般通过控制变量的版本来保证CAS的正确性，对应的java.util. concurrence中的AtomicStampedReference类。 3.无同步方案 可重入代码（Reentrant Code）这种代码也称为（Pure Code），即一个方法，它的返回结果时可以预测的，输入相同的数据，都能返回相同的结果。 线程本地存储（Thread Local Storage）不共享变量，每一个线程都有自己的专享变量，例如ThreadLocal。 13.3 锁优化高效并发是从JDK1.5到JDK1.6的一个重要改进，这个版本有各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等。 13.3.1 自旋锁与自适应自旋为了保持处理器执行时间，线程忙循环（自旋），这就是所谓的自旋锁。自旋锁会占用处理器执行时间，因此超过一定次数以后放弃自旋，最开始的时候默认为10次自旋。 JDK 1.6中引入了自适应的自旋锁，这种情况下考验的是虚拟机对程序锁的状况预测能力，预测能力越好，效率越高。 13.3.2 锁消除锁消除是指虚拟机即使编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。 比如说字符串拼接的时候调用的concatString方法，内部使用StringBuffer对象的append()方法，append()方法是带锁的，如果分析得出不会逃逸到concatString方法之外，那么锁是可以消除的。 13.3.3 锁粗化通常来说锁的粒度越小越好，但是涉及到循环这种操作的时候，就要将锁粗化，防止反复加锁，释放锁带来的额外性能损失。 13.3.4 轻量级锁轻量级锁时JDK1.6之中加入的新型锁机制，“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制被称为“重量级”锁。需要强调的一点是，轻量级锁并不是用来代替重量级锁的，它的本意实在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 轻量级锁本意是为了减少多线程进入互斥的几率，利用了CPU原语Compare-And-Swap（CAS，汇编指令CMPXCHG），尝试在进入互斥前，进行补偿]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-深入理解Java虚拟机-Java内存模型与线程]]></title>
    <url>%2F2019%2F03%2F15%2Fjava-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[12.1 概述衡量一个服务性能的高低好坏，每秒事务处理数（Transaction Per Second，TPS） 12.2 硬件的效率与一致性下图为处理器、高速缓存、主存之间的交互关系： 如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证，因为为了保证处理器内部的运算单元能够尽量被充分利用，处理器可能会对代码进行乱序执行优化（Our-Of-Order Ececution）。类似的Java虚拟机的即时编译器也有类似的指令重排序（Instruction Reorder）优化。 12.3 Java内存模型（Java Memory Model）12.3.1 主内存与工作内存如下图所示： 12.3.2 内存间交互操作Java内存模型中定义了一下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，见12.3.4） lock：作用于主内存的的变量，把一个变量标识为一条线程独占的状态。 unlock：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中。 load：作用于工作内存的变量，把read操作从主内存中得到的标量值放入工作内存的变量副本中。 use：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。 store：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用. write：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。 Java虚拟机还规定了在执行上述8种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起了回写但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（最近发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许区unlock一个被其它线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作） 12.3.3 对于volatile型变量的特殊规则关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile之后，它将具备两种特性： 保证此变量对所有线程可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的（常规变量会有一个线程之间的变量同步，所以会存在不同线程之间的值不等的情况）。 禁止指令重排：不管如何重排序（编译器与处理器为了提高并行度），（单线程环境下，指令执行的最终效果应当与其在顺序执行下的效果一致，否则这种优化便会失去意义。这句话有个专业术语叫做as-if-serial semantics (as-if-serial语义)）程序的结果不能被改变。 对于volatile变量的可见性，实际上volatile变量在各个线程的工作内存中（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。 一条字节码指令可能转化为若干条本地机器码指令，所以一条字节码并不一定代表是原子操作。 由于volatile变量只能保证可见性，使用场景如下。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其它的状态变量共同参与不变约束。 1234567891011volatile boolean shutdownRequested;public void shutdown() &#123; shutdownRequested = true;&#125;public void doWork() &#123; while(!shutdownRequested) &#123; //do stuff &#125;&#125; 12.3.4 对于long和double型变量的特殊规则Java内存模型要求lock、unlock、read、load、assign、use、store、write这八个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位操作来进行，即允许虚拟机实现选择可以不保证64位数据的load、store、read和write这4个操作的原子性。这点就是所谓的long和double的非原子性协定（Nonatomic Treatment of double and long Variables） 虽然Java内存模型允许虚拟机不把long和double变量的读写实现成原子操作，但是一般虚拟机实现都是原子性操作的，所以编程的时候不用特意把long和double变量申明位volatile。 12.3.5 原子性、可见性和有序性 原子性（Atomicity）：变量操作read、load、assign、use、store和write 可见性（Visibility）：可见性指的当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。volatile的特殊规则保证了值能够立即同步到主内存，以及每次使用前立即从主内存刷新。出了volatile之外，还可以通过synchronized和final让变量可见。同步块的可见性是由“对一个变量执行unlock操作之前，必须把此变量同步回主内存中（执行store、write操作）”这条规则活得的。final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其它线程有可能通过这个引用访问到“初始化了一半”的对象），那么其它线程中能看见final字段的值。 有序性（Ordering）：Java内存模型的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。 12.3.6 先行发生原则（happens-before）在计算机科学中，先行发生关联是指的两个具有先后关系以及后执行者受到前面执行者影响的两个事件之间的先后关系，即使这两个事件被计算器优化以后乱序执行了，他们之间也应该有先执行者后执行者。 Java语言无需任何同步手段保障就能成立的先行发生规则表现如下几点： 程序次序执行（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于后书写的操作。准确的说，应该是控制流顺序而不是程序代码车顺序，因为要考虑分支、循环等结构。 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。 volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”指的是时间上的先后顺序。 线程启动规则（Thread Start Rule）：Thread对象的start方法先行发生于此线程的每一个动作。 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到终端事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 12.4 Java与线程在Java中讨论并发主要是讨论线程级别的实现。 12.4.1 线程的实现线程是比进行更轻量级的调度执行单位，线程的引入，可以把一个进行的资源分配和执行调度分开，各个线程即可以共享进程资源（内存、文件I/O等），又可以独立调度（线程时CPU调度的基本单位）。 实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。 1.使用内核线程实现 内核线程（Kernel Level Thread,KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视作为内核的一个分身，这样操作系统就有能力处理多件事情，支持多线程的内核较多多线程内核（Multi-Threads Kernel）。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口—轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程。如下图所示是轻量级进程与内核线程之间的1：1关系图： 系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换，同时由于轻量级进程和内核线程1：1的关系，支持的线程数量有限。 2.使用用户线程实现 从广义上来讲，一个线程只要只要不是内核线程，就可以认为是用户线程（UT，User Thread），因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统的调用，效率会受到限制。 狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。这种进行与用户线程1：N的关系称为一对多的线程模型，如下图所示。 使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。Java、Ruby都曾经使用过用户线程，最终又都放弃使用它。 3.使用用户线程加轻量级进程混合实现 线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合模式下，用户线程与轻量级进程的数量比是不一定的，即为N：M的关系，如下图所示： 4.Java线程的实现 Java线程以Sun JDK来说，它的Windows和Linux版本都是使用的一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的。 在Solaris平台上可以选择一对一和多对多的线程模型。 12.4.2 Java线程调度线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。 协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完后主动通知系统进行切换。 抢占式调度：有系统来分配执行时间，线程的切换不由线程本身来决定（可以通过Thread.yield()让出执行时间，但是没法获取执行时间）。 抢占式调度可以通过线程优先级“建议”系统给某些线程多分配一点执行时间。但是这个并不太靠谱，优先级可能被系统自行改变。 12.4.3 状态转化Java语言定义了5种线程状态： 创建（New）：创建后尚未启动的线程处于这种状态。 运行（Runnable）：包括了操作系统线程状态中的Running和Ready，也就是处于这种状态的线程可能正在执行，也可能正在等待CPU为它分配执行时间。 无限期等待（Waiting）：不会被分配CPU时间，需要被其他线程显示地唤醒。以下方法会让线程先入无限期等待状态： 没有设置Timeout参数的Object.wait()方法。 没有设置Timeout参数的Thread.join()方法。 LockSupport.park()方法。 限期等待（Timed Waiting）：不会被分配CPU执行时间，不过无需等待被其他线程显示地唤醒，在一定时间之后他们会由系统自动唤醒。以下方法会让线程进入限期等待状态： Thread.sleep()。 设置Timeout参数的Object.wait()方法。 设置Timeout参数的Thread.join()方法。 LockSupport.parkNanos()方法。 LockSupport.parkUntil()方法。 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。 线程状态的转换图如下所示：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-深入理解Java虚拟机-垃圾收集器]]></title>
    <url>%2F2019%2F03%2F14%2Fjava-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[3.5 垃圾收集器Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定。如下图所示是HotSpot虚拟机包含的所有垃圾收集器： 图3-5展示了7种作用于不同分代的收集器，连线代表收集器可以搭配使用，所处区域代表时属于新生代还是老年带的收集器。 概念： 并行（Parallel）指多条垃圾收集线程并行工作，用户线程仍然处于等待状态。并发（Concurrent）指用户线程与垃圾收集线程同时执行（但并不一定时并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上 3.5.1 Serial收集器Serial收集器只会使用一个CPU或一条收集线程去完成垃圾收集工作，且垃圾收集时，必须暂停其他工作线程。如下所示时Serial/Serial Old收集器的运行过程： Serial时虚拟机运行在Client模式下的默认新生代收集器。它的优势在于：简单而高效（与其它收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可活得最高效的单线程收集效率。 3.5.2 ParNew收集器ParNew收集器起始就是Serial收集器的多线程版本。如下图所示是ParNew收集器的工作过程： ParNew收集器时徐都运行在Server模式下的虚拟机中首选的新生代收集器，主要是因为只有它能与CMS收集器配合工作。 3.5.3 Parallel Scavenge收集器Parallel Scavenge收集器是一个新生代使用复制算法的收集器， Parallel Scavenge收集的特点是它的关注点与其它收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总耗时的比值。 3.5.4 Serial Old收集器Serial Old是Serial收集器的老年代版本，同样是一个是哦那个“标记-整理”算法的单线程收集器。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 3.5.5 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年带版本，使用多线程和“标记-整理”算法。 3.5.6 CMS收集器（Concurrent Mark Sweep）CMS收集器是一种以获取最短回收停顿时间为目标的，基于“标记-清除”算法收集器。工作过程如下： 初始标记（CMS initial remark） 并发标记（CMS Concurrent mark） 重新标记（CMS remark） 并发清除（CMD Concurrent sweep） 其中，初始标记、重新标记这两个步骤任然需要“Stop The World”，如下图所示。整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS的特点：并发收集、低停顿。但是也有如下几个明显的缺点： CMS收集器堆CPU资源非常敏感。 CMS收集器无法处理浮动垃圾（Floating Garbage）。 “标记-清除”算法实现，会产生大量空间碎片。 3.5.7 G1收集器（Garbage-First）G1是一款面向服务端应用的垃圾收集器，具备如下特点： 并行与并发 分代收集 空间整合 可预测的停顿 G1收集器的运作大致可分为以下几个步骤： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacutaion） 示意图如下：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-深入理解Java虚拟机-垃圾回收器与内存分配策略]]></title>
    <url>%2F2019%2F03%2F13%2Fjava-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[3.1 概述Java内存运行时各区域的各个部分都有各自的回收机制，其中程序计数器、虚拟机栈、本地方法栈随线程创建而创建，销毁而销毁；栈中的栈帧随着方法的进入和退出而有条不紊的执行者出栈和入栈操作。因此，这一部分不需要过多考虑垃圾回收问题。 3.2.1 引用计数法（Reference Counting）给对象添加一个引用计数器，当有一个地方引用它时计数器加一；当引用失效的时候，计数器减一。当引用数量为零时，则认为对象是可以回收的。 引用计数器存在的相互引用的问题。 3.2.2 可达性分析算法（Reachability Analysis）通过可达性分析来判断对象是否存活。这个算法的思路就是通过一系列的成为”GC Roots”的对象做为起始点，从这些借点开始向下所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链的时候，则认为这个对象可以回收。 在Java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（一般说的Native方法）引用的对象。 3.2.3 再谈引用在Java中引用分为强引用，软引用，弱引用，虚引用。 强引用（Strong Reference）是通过new创建的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。 软引用（Soft Reference）用来描述一些还有用但是并非必须的对象。对于软引用关联着的对象，在系统发生内存溢出异常之前，将会把这些对象回收列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才回抛出内存溢出异常。 弱引用（Weak Reference）也是用来描述非必须对象的，但是它的强度比软引用更弱一些，无论当前内存是否足够，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 虚引用（Phantom Reference）也被成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是在对象被垃圾回收器回收的时候收到一个系统通知。 3.2.4 生存还是死亡即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候他们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与GC Roots相链接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行回收。 如果这个对象被判定为有必要执行finalize()方法，那么对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的，低优先级的Finalizer线程区执行它（虚拟机会触发该方法，单不承诺执行完成）。finalize()是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象在finalize()中成功拯救自己-只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那么在第二次标记时它将被移出“即将回收”的集合。 3.2.5 回收方法区永久带的垃圾收集主要回收两个部分内容：废弃常量和无用的类。废弃常量的回收跟堆中的对象类似，常量不再被引用的时候可以回收。无用的类判断能否回收的条件则苛刻许多 该类所有的实例都已经被回收，也就是在Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过放射访问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，但并不是和对象一样，不适用了就进行回收。这个是通过一系列的jvm配置进行设置的。 3.3 垃圾回收算法3.3.1 标记-清除算法（Mark-Sweep）最基础的收集算法时“标记-清除”，首先标记需要回收的对象，然后统一回收所有被标记的对象。它的不足由以下两点： 效率问题：标记和清除的两个过程效率都不高 空间问题：清除对象以后的内存空间时不连续的，当要分配较大对象的时候，如果找不到足够大的单块内存分配，就需要提前促发对象回收动作。 3.3.2 复制算法为了解决标记-清除散发的效率不足问题，复制算法应运而生。它将内存分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就把还存活的对象复制到另一半，然后将已经使用过得内存块这一半一次性清理掉。这种方式实现简单，也不会有内存碎片的问题。只是这种算法浪费了一半的内存空间做为备用。 现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的98%的对象都是“朝生夕死”的，所以并不需要按照1：1的比例来划分内存空间。而是按照Eden:%80 From Survivor:10% To Survivor:10%分配，每次使用Eden和一块Survivor空间。内存回收的时候将存活着的Eden空间和Survivor空间的对象一次性复制到另一块Survivor空间中，这样子，就只有10%的一块Survivor空间被浪费掉了。当然也有可能内存回收的时候存活的对象占用的内存空间超过了10%，这个时候就需要其他内存（老年带）进行分配担保（Handle Promotion）； 3.3.3 标记-整理算法（Mark-Compact）复制算法适合对象存活率较低的场景，所以老年带一般不能直接选用这种算法。根据老年带的特点，有人提出了另一种“标记-整理”算法，标记过程任然与“标记-清除”算法一样，但后续步骤不是直接对对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。 3.3.4 分代收集算法（Generational Collection）当前商业虚拟机的垃圾收集都采用“分代收集”算法。在新生代中，每次垃圾收集都发现由大量对象死去，只有少量存活，适用复制算法。 老年带对象存活率高、没有额外空间进行担保，适合“标记-清除”或者“标记-整理”算法来进行回收。 3.4 HotSpot的算法实现（看不懂这一章）3.4.1 枚举根节点以可达性分析从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中。 可达性分析过程中必须冻结整个执行系统才能保证分析过程中不会出现对象引用关系变化，正是因为这个GC进行时必须停顿所有Java执行线程（Sun将这件事情成为“Stop-The-World”），即使在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。 由于目前的主流Java虚拟机使用的都是准确式GC（虚拟机可以知道内存中某个位置的数据具体是什么类型），所以当执行系统停顿下来后，并不需要一个不漏得检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组成为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。 3.4.2 安全点（Safepoint）在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举。OopMap内容变化的指令非常多，如果为每一条指令生成对应的OopMap，将会需要大量的额外空间，这样GC的空间成本将对变得很高。 程序并不是在所有地方都能停下来GC，只有在到达安全点（Safepoint）时才能暂停。安全点地选定既不能太少以至于让GC等待时间太长，也不能国语频繁以至于过分增大运行时地负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准选定地。“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等等。 对于安全点还有一个问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。有如下两种方案： 抢先式中断（Preemptive Suspension） 主动式中断（Voluntary Suspension） 其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。 而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅是简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志时就自己主动中断挂起。轮询标志的地方和安全点时重合的。当需要暂停线程时，虚拟机把内存页设置为不可读，线程执行到内存中该汇编指令时就会产生一个自陷异常新号，在预先注册的异常处理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。 3.4.3 安全区域（Safe Region）安全点似乎完美解决了如何进入GC的问题，但是安全点只保证了程序在不太长的时间内就会遇到可进入GC的安全点。但是如果线程处于Sleep或者Blocked状态，这时候线程无法响应JVM的中断请求。这种情况下，就需要安全区域来解决。 安全区域是指在一段代码片段之中，引用关系变化不会发生变化。在这个区域中的任意地方开始GC都是安全的，可以理解为安全点的扩展。 在线程执行到安全区域中的代码时，首先标志自己已经进入了安全区域，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举（或者整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待知道收到可以安全离开安全区域的信号为止。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-深入理解Java虚拟机-对象的创建,内存布局,访问定位]]></title>
    <url>%2F2019%2F03%2F11%2Fjava-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[2.3.1. 对象的创建对象的创建主要过程包含了类加载检查、对象内存分配、并发处理、内存空间初始化、对象设置、执行init方法等。主要流程如下： 1. 类加载检查虚拟机遇到一条new指令时，首先讲去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则首先要执行相应的类加载过程。 2. 分配内存对象所需内存的大小在类加载完成后便可完全确定（对象的内存布局），为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。 根据堆中的内存是否规整（选用哪种方式取决于Java堆是否规整，而Java堆是否规整取决于jvm采用的内存收集器是否有compact功能）分两种内存分配方式： 指针碰撞（Bump the Pointer） 假设Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的放在一边，中间放着一个指针做为分界点的指示器，那分配内存就是把这个指针向空闲空间移动分配的内存大小的距离。 空闲列表（Free List） Java堆中的内存不连续的情况下，jvm维护一个列表，记录哪些内存空间可用，哪些内存空间不可用。当进行内存分配的时候，在空闲列表中找一块空间足够大的内存块分配内存。 3. 并发处理对象创建在虚拟机是一个非常频繁的行为，即使是只修改一个指针的位置，在并发情况下也并不是线程安全的，可能出现正在给A对象分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案： 同步 对内存分配的动作进行同步处理–实际上虚拟机采用CAS配置失败重试的方式保证更新操作的原子性。 本地线程分配缓冲(Thread Local Allocation Buffer) 把内存分配的动作按照线程划分在不同的空间之中进行。即每个线程在Java堆中预先分配一小块内存。哪个线程需要分配内存，就在那个线程的TLAB上分配，只有当TLAB的空间不足的重新分配TLAB的时候才需要线程同步锁定。jvm配置参数-XX:+/-UseTLAB 4. 内存空间初始化虚拟机将分配到的内存空间初始化为零值（不包括对象头），如果使用TLAB，这一过程也可以提前至TLAB分配时进行。 这一过程可以让对象在使用的时候不用赋值就可以使用。 5. 对象设置虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分带年龄等信息。这些信息存放在对象头中。 6. 对象init()从虚拟机的角度来看，对象已经产生了。从Java角度来看，对象的创建才刚刚开始-init()方法还没有执行，对象的所有字段都还是零值。 所以，一般来说由字节码是否跟随invokespecial指令所决定，执行new指令之后会接着执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才选完全产生出来。 2.3.2. 对象的内存布局在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Object Head）、实例数据（Instance Data）和对齐填充（Padding）。 1. 对象头HotSpot虚拟机的对象头包含两部分信息： 1. 存储对象运行时数据哈希码、GC分代年龄、锁状态标志、线程所持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位虚拟机（未开启压缩指针1，指针压缩2）中分别为32bit和64bit，官方称他为Mark Word。 2. 类型指针类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。(句柄方式访问对象的话是通过类型数据指针来查找的) 如果对象是一个Java数组，对象头中还存有记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小 2. 实例数据实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论从父类继承而来或者在子类中定义的，都需要记录起来。这部分的存储顺序会收到虚拟机的分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义的顺序的影响。HotSpot虚拟机默认的分配策略位longs/doubles、ints、shorts/chars、bytes、booleans、oops（Ordinary Object Pointers），从分配策略来看，相同宽度的字段总是分配到一起。在满足这个前提条件的情况下，在父类中定义的变量回出现在种类之前。如果CompactFiles参数值位true（默认为true），那么子类中较窄的变量也可能回插入到父类的变量空隙之中。 3. 填充数据起到占位符的作用，由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换而言之对象的大小必须是8字节的整数倍。而对象头刚好是8字节的整数倍（1倍或者2倍）。因此，当对象的实例数据不是8字节的整数倍的时候，需要通过填充数据来补全。 2.3.3. 对象的访问定位Java程序通过栈上面的reference数据来确定使用的具体对象。由于reference类型在Java虚拟机中只规定了一个指向对象的引用，并没有定义这个引用通过何种方式去定位、访问堆中的对象的具体位置，所以对象的访问方式也是取决于虚拟机的实现而定的。目前主流的访问方式有使用句柄和直接内存指针两种。 使用句柄的方式访问，那么Java堆中将会划分一块内存做为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。如下图所示： 使用直接指针访问，那么Java堆对象的布局中就必须考虑如何防止访问数据类型数据的相关信息，而reference中存储的直接就是对象地址。 这两种对象的访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾回收时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常平凡，因此这类开销积少成多也是一项非常可观的执行成本。Sun Hotspot采用的就是直接指针访问的方式，但是从真个软件开发范围来看，使用句柄的方式十分常见。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[homebrew更新阿里源]]></title>
    <url>%2F2019%2F03%2F08%2Fhomebrew%E6%9B%B4%E6%96%B0%E9%98%BF%E9%87%8C%E6%BA%90%2F</url>
    <content type="text"><![CDATA[替换为阿里源123456789101112# 替换brew.git:cd &quot;$(brew --repo)&quot;git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git# 替换homebrew-core.git:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git# 应用生效brew update# 替换homebrew-bottles:echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&apos; &gt;&gt; ~/.zshrcsource ~/.zshrc 还原为官方源12345678# 重置brew.git:cd &quot;$(brew --repo)&quot;git remote set-url origin https://github.com/Homebrew/brew.git# 重置homebrew-core.git:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://github.com/Homebrew/homebrew-core.git#删除zshrc HOMEBREW_BOTTLE_DOMAIN内容]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>homebrew</tag>
        <tag>阿里源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-深入理解Java虚拟机-Java内存区域与内存溢出异常]]></title>
    <url>%2F2019%2F03%2F07%2Fjava-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[2.2 运行时数据区域(Java VM runtime data areas) Java虚拟机在执行Java程序的过程中会把它管理的内存划分位若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而简历和销毁。如下图所示，Java运行时数据区域分为以下几个部分： 2.2.1 程序计数器(Program Counter Register)程序计数器是一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。 由于Java虚拟机的多线程是通过线程切换cpu时间片实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的PC计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此区域内存是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 2.2.2 Java虚拟机栈（Java VIrtual Machine Stacks）于PC counter一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同事回创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 虚拟机栈中的局部变量表存放了编译期可知的各种功能基本数据类型（boolean、byte、char、int、short、long、double、float)、对象引用（reference类型，它不等通于对象本身，可能是一个指向对象起始地址的引用指针，也可能是只想一个代表对象的句柄或其他与此对象相关的位置）和returnAddress（只想了一条字节码指令的地址）。 在Java虚拟机规范中，对这个区域规定了两种异常情况： StackOverflowError 线程请求的虚拟机栈深度大于虚拟机所允许的最大深度。 OutOfMemoryError 如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存的时候。 2.2.3 本地方法栈（Native Method Stacks）本地方法栈和虚拟机栈所发挥的作用非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务。同样的本地方法栈也会抛出StackOverflowError和OutOfMemoryError。 2.2.4 Java堆（Java Heap）对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是线程共享的一块内存区域，在虚拟机启动时创建。 此区域的唯一目的就是存放对象实例，在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT（Just-In-Time）编译器的反战和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么绝对了。 Java堆是垃圾回收器管理的主要区域，Java堆垃圾回收采用分代收集算法，该区域的划分和虚拟机配置参数如下，分为两大块Young Generation和Old Generation，Permanent Generation属于接下来要讲的方法区。而Young Generation又可以细分为Eden（伊甸区）、From Survivor、To Survivor区。 2.2.5 方法区（Method Area）方法区也是线程共享的内存区域，他用于存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法去描述为堆的一个逻辑部分，但是它有一个别名叫做非堆（Non-Heap），目的应该是与Java堆区分开来。 方法区又被称之为永久带（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久带来实现方法区而已。这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存，省去专门为方法区开发内存管理代码的工作。对于其它虚拟机来说不存在方法区。 在jdk1.8之前，永久带在虚拟机运行时数据区域的分块如下： 在jdk1.8时，永久带被合并至Metaspace，如下所示： 根据Java虚拟机规范的规定，当方法区无法满足内存分配的需求时，将抛出OutOfMemoryError异常。 2.2.6 运行时常量池（Runtime Constant Pool）运行时常量池时方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 2.2.7 直接内存（Direct Memory）直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。由于此区域也可能导致OutOfMemoryError异常，故放在一起讲解。 在JDK1.4中心加入了NIO(New Input Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/0方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象做为这块内存的引用操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 该区域收到本机总内存大小以及处理器寻址控件的限制，动态扩展时如果申请不到内存会出现OutOfMemoryError异常。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶段性总结 2016.03-2019.02]]></title>
    <url>%2F2019%2F01%2F30%2F%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-2016-03-2019-02%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[协程有什么好处]]></title>
    <url>%2F2019%2F01%2F29%2F%E5%8D%8F%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%2F</url>
    <content type="text"><![CDATA[引用来源知乎，协程的好处有哪些。 作者：阿猫链接：https://www.zhihu.com/question/20511233/answer/24260355来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 一开始大家想要同一时间执行那么三五个程序，大家能一块跑一跑。特别是UI什么的，别一上计算量比较大的玩意就跟死机一样。于是就有了并发，从程序员的角度可以看成是多个独立的逻辑流。内部可以是多cpu并行，也可以是单cpu时间分片，能快速的切换逻辑流，看起来像是大家一块跑的就行。 但是一块跑就有问题了。我计算到一半，刚把多次方程解到最后一步，你突然插进来，我的中间状态咋办，我用来储存的内存被你覆盖了咋办？所以跑在一个cpu里面的并发都需要处理上下文切换的问题。进程就是这样抽象出来个一个概念，搭配虚拟内存、进程表之类的东西，用来管理独立的程序运行、切换。 后来一电脑上有了好几个cpu，好咧，大家都别闲着，一人跑一进程。就是所谓的并行。 因为程序的使用涉及大量的计算机资源配置，把这活随意的交给用户程序，非常容易让整个系统分分钟被搞跪，资源分配也很难做到相对的公平。所以核心的操作需要陷入内核(kernel)，切换到操作系统，让老大帮你来做。 有的时候碰着I/O访问，阻塞了后面所有的计算。空着也是空着，老大就直接把CPU切换到其他进程，让人家先用着。当然除了I\O阻塞，还有时钟阻塞等等。一开始大家都这样弄，后来发现不成，太慢了。为啥呀，一切换进程得反复进入内核，置换掉一大堆状态。进程数一高，大部分系统资源就被进程切换给吃掉了。后来搞出线程的概念，大致意思就是，这个地方阻塞了，但我还有其他地方的逻辑流可以计算，这些逻辑流是共享一个地址空间的，不用特别麻烦的切换页表、刷新TLB，只要把寄存器刷新一遍就行，能比切换进程开销少点。 如果连时钟阻塞、 线程切换这些功能我们都不需要了，自己在进程里面写一个逻辑流调度的东西。那么我们即可以利用到并发优势，又可以避免反复系统调用，还有进程切换造成的开销，分分钟给你上几千个逻辑流不费力。这就是用户态线程。 从上面可以看到，实现一个用户态线程有两个必须要处理的问题：一是碰着阻塞式I\O会导致整个进程被挂起；二是由于缺乏时钟阻塞，进程需要自己拥有调度线程的能力。如果一种实现使得每个线程需要自己通过调用某个方法，主动交出控制权。那么我们就称这种用户态线程是协作式的，即是协程。 本质上协程就是用户空间下的线程。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云游四方-大理-丽江-香格里拉-泸沽湖]]></title>
    <url>%2F2018%2F12%2F24%2F%E4%BA%91%E6%B8%B8%E5%9B%9B%E6%96%B9-%E5%A4%A7%E7%90%86-%E4%B8%BD%E6%B1%9F-%E9%A6%99%E6%A0%BC%E9%87%8C%E6%8B%89-%E6%B3%B8%E6%B2%BD%E6%B9%96%2F</url>
    <content type="text"><![CDATA[这个是草稿，实在写不下去了 行程原计划时加上往返路程一共九天，最终只呆了八天回来了，感觉有点累。 2018-12-15 深圳 - 昆明 - 大理 大理天气阴天7-18℃ 2018-12-16 崇圣寺三塔公园 - 洱海骑行 大理天气多云5-18℃ 2018-12-17 甘海子 - 玉龙雪山 - 蓝月谷 丽江天气晴6-19℃ 2018-12-18 长江第一湾 - 虎跳峡 - 普达措国家公园 大雪零下6-零上3℃ 2018-12-19 香巴拉时轮坛城 - 象山公园 - 独克宗 晴 2018-12-20 泸沽湖观景台 - 猪槽船 - 篝火晚会 晴 2018-12-21 草海 - 走婚桥 - 摩梭家访 晴 2018-12-22 洱海骑行 - 采草莓 - 深圳 晴 注意事项 云南海拔高，紫外线很强烈，记得一定要带防晒的，要不一下子就晒黑了。 天气干燥，记得带保水的，不行大宝就很合适。 一定要带保温杯，很多地方都有热水打，多喝温水，不要直接喝冷水。 不要随便就被人拉这里去玩那里去玩，防止被坑，尽量走线上平台交易，至少还能打差评。 带一些零食，有时候坐车三四个小时，可以吃点东西，或者吃不惯的时候也可以填一下肚子。 如果能带墨镜的话尽量带上，太阳太强烈了，拍照的时候不方便。 去寺庙不要戴帽子，寺庙内不要拍照，不要踩人家门槛，左脚先跨过去，观光一般顺时针绕行，你可以不信仰，但是还是要尊重别人的习俗。 备点一元零钱，很多地方上厕所要收费，以备不时之需。 具体行程day1（2018-12-15 周六 天气多云，气温）深圳 - 昆明 - 大理第一天严格意义来说一直是在赶路的，主要是说一下时间。我们是早上7：35-10：15从深圳到昆明的飞机。然后转乘地铁从昆明长水机场到昆明火车站，再乘车前往大理。 深圳 - 昆明长水机场 耗时约2小时，票价1400左右，两人 昆明长水机场 - 昆明火车站 地铁6元/人，耗时约一个小时，从机场中心站坐6号线经过3站到达东部汽车站，转乘地铁3号线,经过6站, 到达东风广场站，再转乘地铁2号线,经过2站, 到达环城南路站。建议在这里下车，因为去昆明火车站下车也要绕着火车站走很远（大约800米），而且人又少，还不如在环城南路站下车，走北京路到达火车站正门。另外也可以直接坐从机场到昆明站的大巴，时间可能更短，25元/人。 昆明火车站 - 大理火车站 耗时约2小时，一等座231元/人，D4120动车。走到昆明火车站才发现没有买票，临时买的12：57的火车票，云南的火车旅游线都很宽敞，一等座远远大于深圳的一些一等座，非常舒适。下午15：05到达大理火车站。 大理火车站 - 大理古城 耗时约1小时，3元/人。从大理火车站出来以后可以看到广场上面有很多8路车，PS：也有很多私人在拉客，15元/人，感觉没啥必要。回来的时候不堵车才30多分钟就到了。这里是从大理火车站坐到大理古城东门的风花雪月酒店站下车，如果不知道怎么去客栈的话可以叫客栈老板过来接就好了。请大家务必注意的是，门口有很多推荐住房什么乱七八糟的，建议大家都在网上订好，至少你还能给差评，现场的就是无保障，容易被人宰，尤其是你不会砍价的时候。 大理古城 - 才村码头 耗时十分钟左右，8元。因为我们到的时候已经四点多了，所以放完东西我们就去了才村码头转转。大理古城出来有很多那种电动车，从大理古城过去砍价到8元（有人叫20元，果断砍价）。一路上可以看到很多耕种的本地人，还有很多草莓园，我们返程去大理的时候有过去采摘（25元/斤），特别香甜，比深圳便宜多了。乘车过去才村码头拍拍照，然后转了一下湖滨生态园。 才村码头 - 大理古城 稍晚天冷就返回大理古城准备用餐。 大理古城 - 人民路 向客栈老板打听以后决定去人民路吃点东西，沿着人民路逛了一圈，感觉实在是跟别的古城没什么区别，走到洋人街附近的时候就绕回去了。中间见识了一路的烤榴莲，银饰店，以及各种本地的水果如：人参果，蛇皮果之类的（水果不要买多，可能吃不惯）。晚餐实在是不知道吃什么就在路边随便找了一家店吃，结果随便了一个本地的那种自助烧烤，有一块石板撒上油自己烤的那种，非常难吃，建议不要吃。 回客栈休息 day2（2018-12-16 周日） 崇圣寺三塔公园-才村码头-大理古城-洱海环行原计划时早上起床去才村码头看日出的（云南这个季节的日出大概是在八点左右，七点四十左右天已经开始变白，具体的时间可以通过天气app查看日出日落的时间），因为打不到车，然后太早了没地方租车所以耽搁了，然后一下子睡到了九点多才起来。吃完了早餐以后，就去了崇圣寺三塔公园。 大理古城 - 崇圣寺三塔公园 从大理古城到崇圣寺三塔公园大概也就一两公里，我们是用滴滴打车过去的，一般13，14元即可。 崇圣寺三塔公园 - 大理古城 从公园会去以后基本上已经到了午餐时间，在大理古城又找不到什么好吃的，所以我们就在东门进来一点的地方吃了一个云南的米线，味道一般。 大理古城 - 洱海骑行 美。 大理古城 - 丽江 耗时约2-3小时，费用60-100/人不等。我们这里是找客栈老板帮我们订的，有个不好的点是一个小面包车在大理古城一直转接人，可能要一个小时或者更短。我们订的七点半的车，结果六点四十就来接人了，饭还没吃完。然后跟这他接人转了快一个小时。所以不要轻易找客栈老板，还不如自己打车去车站，时间可控一些。到达丽江以后我们是到的丽江高快客运站，位于丽江古城的西北角，还有一个丽江客运站位于丽江古城的南边一公里左右的地方。我们那个客栈老板就有点分不清位置，让我绕了一圈去南门的分店。 崇圣寺三塔公园我们是在飞猪订的景区门票，包含了崇圣寺三塔公园里面的单程电动车票，一般建议下行的时候才坐电动车，其实也可以不坐电动车。崇圣寺三塔公园其实很小，玩两个小时绰绰有余，套票里面包含了三塔倒影公园（下午四点到五点时最佳时间，因为我们是上午去的，所以就略过了这个景点）。其实比较理想的是上午去苍山-洗马潭，下午去崇圣寺三塔公园。由于天气不是很好，我们把这一个行程略掉了，晚上提前去丽江古城。 洱海骑行下午本来也没想好干什么，后来就想着去骑电动车环游洱海，不过我们两个人都不会骑电动车（我还是八年以前学过，但是没学会就放弃了）。在路边小店租车的时候，老板一听说我们不会骑，立马就从主动推销改为了主动拒绝，这个是挺好的。后来我实在没忍住在网上租了一个（主要是考虑到飞猪有免押金），到喜洲往返的55元，环洱海的110元（价格代表能够跑的距离，一旦跑达到没电是一件非常痛苦的事情。我老婆的一个朋友现在每次跟人说都是不要去云南就是因为电动车骑到一半没电了，而且赶上下雨）。环洱海大概120公里，路况不好且骑的不会快，加上停下来拍照肯定是需要一天的时间的，所以我们选择了喜洲往返的套餐，现在想想这是去大理做的最明智的一件事情了。在飞猪上面下单以后，大概过了十几分钟老板把电动车送过来（古城内都是送的，还的时候老板也是古城内上门取的）。一路上真的是看到了很多很多漂亮的风景，主要是云南的天太蓝了，感觉美的不真实。 day3（2018-12-17 周一）甘海子-丽江玉龙雪山-蓝月谷这里报的是那种一天的团，基本上都是六点半到七点半来四处接人，所以起的很早，我们一行加导游一共九人。费用是369元/人，含午餐，中午基本上都是那种腊排骨煮鸡肉，加上一些菜，加了辣椒酱后味道还可以。然后还有一罐氧气，和一件防寒服，就是那种大衣样式的。行李的话是直接丢在昨晚睡觉的客栈。 丽江古城 - 甘海子 不知道为啥甘海子也算一个景点，刚到甘海子还很早，特别冷，随便拍了下照片就走了。 甘海子 - 玉龙雪山 先是在山脚下坐大巴到山腰去排队坐缆车，淡季都排了半个小时。进去的地方有卖一些巧克力之类的，不要买，除非你很饿，所谓抗高原反应就是心理暗示罢了。带好旅行社发的氧气提前吸一下就好了，有备无患。坐上缆车也就几分钟就到了山上，然后往上有一个100多米高德台阶可以走，体力充沛可以爬一下，我们当时爬到了中间的小卖部那里，然后我老婆头晕就下来了。 玉龙雪山 - 蓝月谷 返回山腰的时候也是坐缆车，然后坐到蓝月谷的大巴车，道终点站下车以后司机过来接我们去午餐。午餐完毕以后导游又把我们送到下大巴的蓝月谷，然后大家自由活动，沿着蓝月谷的几个湖网上。蓝月谷的水确实非常的漂亮，有几个湖视清澈见底的，也有几个就是蓝色的湖水，如梦如幻。蓝月谷的水是玉龙雪山融化的雪水，比较凉，之所以看起来是蓝色是因为水中富含铜离子，所以蓝月谷的水是不能饮用的。这里因为晚上没有休息好，早上又起得很早，直接导致下午头痛的不行。然后我老婆又一直叫我摆姿势拍照，录视频，头痛到不行不行的，最后还给我脸色看，委屈blabla。 蓝月谷 - 丽江古城 蓝月谷走完以后，导游开车到上游的桥那里直接接我们一起返回丽江古城勒。到了客栈五点多刚刚好。 day4（2018-12-18 周二）长江第一湾-虎跳峡-普达措国家公园-藏王土司宴之所以今天来香格里拉也是冲着下雪过来的，运气真好，还真下雪了，遇上了香格里拉2018年的第一场雪。可把我老婆这个广东人高兴坏了，打成了人生成就：人生的第一场雪。本来行程里面周三才是普达措，由于我们是散客拼团，所以导游的行程是第一天（周二）去普达措，正好是下雪的时候。算是非常完美了，因为晚上雪停了，然后第二天晴天雪融化了。 此次是散客拼团，一个大巴车只有22人，一个藏族女导游叫拉姆，一个司机，算是淡季的福利吧。团里面有一个北京的四人大家庭，爸爸妈妈，女儿女婿，爸爸有点像网上说的朝阳群众，热心，管的宽。还有一对来自成都的叔叔阿姨，阿姨的模样和行为一看就是那种特别幸福的女人。前面还有两位是来自黑龙江的东北大汉，父子两。其他的没什么交集，所以记不清。 长江第一湾 无法理解长江第一湾也是个景点 虎跳峡 耗时约1小时。虎跳峡确实是一个值得一去的地方，我们去的时候水流不是很急，风特别大，大概玩了一个小时就走了。 午餐 这一顿午餐是我在云南吃过的最差的一顿了，七八个素菜，全靠老乡腿脚品尝的牦牛肉酱和松茸下饭了。 普达措国家公园 吃完饭接着往普达措赶，天渐渐下起了雪，车外白雪茫茫，车上广东人一路上高兴的直跳。去普达措的路上导游会推荐大家去买氧气瓶和高原维能，氧气好像是68/瓶，高原维能是48/支，导游推荐大家一人两瓶氧气，两瓶高原维能，其实完全没必要。我们昨天在玉龙雪山的氧气瓶还有剩下两瓶，完全够用了。只要保证一人一瓶完全够了，还有富余。普达措国家公园上去的时候等了半个小时大巴，下来的时候等了快五十分钟大巴，这点是非常让人诟病的。上去的时候我们是在属都湖下车，不行3.3公里到达终点站坐车下来的。 藏王土司宴 晚上吃饭在藏王土司宴，就是一人一个小火锅，中间会有藏民跳舞还有跟大家互动的过程。 长江第一湾正如前面所说，有点搞不懂这么一个地方怎么会算得上一个景点，感觉就是一个很普通的地方。当然了，也有可能是我们来得季节不对吧。 虎跳峡虎跳峡是中国云南省丽江一處峡谷，位于玉龙与中甸之间的金沙江干流上。相传金沙江逢枯水期时，有猛虎下山，在此江中的礁石上稍一脚后腾空便越过，故称「虎跳峡」，江中的礁石則稱作「虎跳石」。 虎跳峡因该是一个比较有名的景点，我们去的时候刚好是枯水季节，没有领略到虎跳峡的雄浑壮阔，不过也正式因为这样，所以才看到了虎跳石。下车往上看对面云雾缭绕，山顶还有积雪，前方就是悬崖，山涧风很大，有一点冷。沿着台阶往下走，往下看还是有一点瘆人的。走到下面平台的时候，大家都在标志性的虎跳石那里合影留念，还好不是旅游旺季，排队拍了个照。旁边有一些很脏的玻璃栈道，应该是涨水的时候水冲的。尽管是枯水季节，但是也能听到水流冲击的声音，想想要是洪水季节，该是何等的壮阔呀。 普达措国家公园普达措国家公园位于云南省迪庆藏族自治州香格里拉市境内，最高海拔4159.1米，年平均气温5.4℃。至今保持完整的原始森林生态系统，奥运火炬香格里拉站的传递就曾经在这里进行。 藏王土司宴藏王土司宴吃小火锅，进门的时候会有人献哈达拍照，后面会打印出来问你是否要，如果需要的话是20元/张。进门坐下入席坐下以后，当地的藏民会载歌载舞欢迎大家的到来，总的来说气氛还不错，会有一些互动环节。不过味道的话比较一般吧，可以免费加菜，会有藏民吃的煮土豆，饼，还有青稞酒之类的。我们团里一个可爱的成都大叔喝了一些酒以后还上去唱了两曲，然后阿姨还上去献了哈达，特别有爱。不过宴会进行到晚声的时候突然停电了，所以后面的篝火晚会就取消了。 酒店休息停电以后大伙就坐旅行车回到了酒店休息，结果酒店也没有电，一直在用发电机发电，提着行李到了房间以后就准备洗漱休息了。房间的配置相当不错，开始听说给我们订的是单间我还挺纳闷的，结果一进房间远超预期。房间里面已经有油汀预热了，还是蛮舒服的，不会像空调那么一股味道还特别干燥。不过我们的房间对着酒店的发电机，特别吵，对我没啥大的影响，对我老婆影响比较大。而且凌晨一点多的时候整个酒店直接就没电了，第二天起来用的是手机照明。 day5（2018-12-19 周三）香巴拉时轮坛城-龟山公园-独克宗古城今天是两天的香格里拉行程的第二天，早上七点四十导游预约了叫早服务，八点洗漱完毕去到餐厅层吃饭。早餐是有花卷，白粥，蛋糕，咸菜，面条，一人一个鸡蛋，对于我们俩来说只要有白粥咸菜就算是okay了。早餐完八点二十司机接我们去到另一个酒店接另外的部分团员，结果他们一上车就来抱怨早餐难吃，只有白粥，然后听我们说早餐有那么多选择大伙又叽叽喳喳的聊了一会。 香巴拉时轮坛城香巴拉时轮坛城严格意义来讲是一个现代化的建筑，大家也可以去看看古色古香的松赞林寺，不过去看看也是不错的。 龟山公园这里有一个很大的转经筒，需要很多人合力才能转起来，大家可以试试。 独克宗古城我们只是在下面的红军纪念馆和旁边的博物馆转了一下，没有去独克宗古城游玩，淡季人也比较少，加上积雪较多地面丝滑，就没有过去转了。 香巴拉时轮坛城稍晚，大伙到了香巴拉时轮坛城，导游买票以后大伙乘电梯到达八楼，有坛城里面的工作人员带领大家参观。带我们团的是一个汉族的小伙，他老家是云南的，在拉萨的佛学院学成以后申请回香巴拉时轮坛城工作。 香巴拉时轮坛城从2005年开始修建，耗时十年建成，2015年初期只向宗教人士和政府官员开放，后来响应习主席的号召开始面向大众开放。到达八层以后，工作人员向我们介绍了香巴拉时轮坛城的一些知识，因为对历史背景不太了解，一下子就忘了。中间还介绍了天珠，转经筒，唐卡，等等，不过坛城里面都是禁止拍照的，只有在坛城外面才可以拍照。 沿着楼梯往下走的时候工作人员一边转着转经筒，一边带我们来到了佛祖佛母的善恶相的侧面参观，中间有对佛祖佛母做了一个大致的介绍。例如踩在脚下代表欲望，贪婪的男人，和抬佛祖佛母脚的女人在祈求佛祖佛母放过自己的男人。然后当我们走到下面的烧酥油灯的地方，大家可以花个十几二十块买一盏小的，或者花个几十块买一盏大的酥油灯去许一个愿，祈求平安幸福，告诫心灵。可能大家会比较关心如果愿望达成了是否需要还愿，工作人员也有说到在大乘佛教里面是没有必要还愿这一说的，所以大家也不用返回去还愿。 龟山公园龟山公园有着世界上最大的转经筒，从下面沿着满是积雪的石阶小心翼翼的往上走，来到上面的庙前。然后走到世界上最大的转经筒之前，招呼上同行的旅人，大伙一起合力转了一圈转经筒。感觉还是不错的，然后顺便在边上拍拍照。 独克宗古城独克宗古城在2014年的时候一场大火把整个古城付之一炬，后面翻修了以后人气不是特别好，后面政府就规定每个去香格里拉的旅行团都要去独克宗转一下，算是政策性增加人气吧。 集合以后导游就开始问大伙有谁要去看看蜜蜡和天珠的，我们团有个一家三口跟这导游去看几十分钟，其他人因为下雨全都在路边屋檐下等着。等他们回来以后说看中一个天珠，要价八万，这里完全不建议大家去购买这些。首先天珠本身就是最近几年炒的厉害的，尤其是李连杰佩戴以后，另外也无法辨别真伪。 人齐以后大家一起到大巴车出发，这里有个小插曲。一对小情侣去了边上的面包店买面包，但是发车的时候导游以为他们到了，所以直接开车走了，然后小情侣打电话给导游，司机就转回去接他们。司机很不客气的说我的油费都比你们的面包值钱了，本身来讲就是这个导游自己失职了还来指责游客。 午餐及返程出发以后准备去用餐，到了一个藏民家以后上到二楼有很多卖藏红花，天麻，松茸，牦牛肉之类的。大家依次坐下以后等了很久都不见上菜上饭，一问才知道是导游说上菜才会上菜，结果导游又一直在等着我们买东西了。催了好几次以后才开始上菜，有点恶心巴拉的，饭菜也不怎么样。午餐过后下楼导游还让我们填了一个表给她评分，违心的填了一个好。 中午用餐完以后大伙就乘车准备返回丽江了。这发现一个很有意思的地方，去往丽江方向的大巴车都需要清洗以后才能进程。这应该算是一个政策性扶贫了，为当地民众谋生计。 下午五点多到达丽江以后导游没有像出发的时候一样送回各个酒店，而是在几个集中的地方下人，远的就给了十元车费。 晚餐及住宿晚上依然住在丽江古城，不过这一次从城南住到了城北，打车到客栈放完行李以后我们就启程打车去往花马街吃饭。 到了花马街入口的时候我们下车不行准备路上看看吃什么，路边的店很多都是烧着个篝火，然后会有一些阿姨穿着民族服饰跳舞。走着走着来到了一个新开的超市前面，老婆决定去买一些零食带上填肚子，然后我的书包又被塞满了。逛完超市以后我们也不是很想接着走了，所以看了下边上的店，有一个叫阿勒丘食府的店，马路两边有两家，看了下口碑，有套餐。进去问了以后结果不支持，但是我们俩又不想走了，就坐下来看了一下菜单点了几个菜。一个土豆丝，一个黄花菜炒蛋，一个毛血旺，份量都很足，但是味道就一般了。 吃完饭以后打算徒步走回去，沿着丽江古城里面的小河一直往下走呀走呀。中间有很多酒吧，人气特别好，不过我们两个没有进去，而是慢慢走呀走，走回酒店以后洗漱休息。毕竟明天还要赶早起床出发去泸沽湖。 day6（2018-12-20 周四）金沙江-泸沽湖观景台-泸沽湖-猪槽船-篝火晚会从丽江到泸沽湖大概三四个小时的车程，我们两个报的是两天的团 早上六点半开始起床收拾东西，洗漱完毕出发，在路口买了早餐以后等车过来。本来约的是7:15的车，结果到了7:20才到，估摸着应该是人太多太分散了。果然，这个散客团居然有40个游客，外加一个导游一个司机。大概到八点左右才把整个团的人接齐了，出发去泸沽湖。 金沙江 其实金沙江并不是我们行程中的一个景点，只是会路过而已，但是这一段路的金沙江实在太美了，所以就点出来一下。 泸沽湖观景台 鸟瞰泸沽湖全境，适合拍拍照。 泸沽湖 来到泸沽湖边上，近距离欣赏泸沽湖的美景。 猪槽船 乘船登录小岛，可以在岸边买几个面包边乘船边喂食海鸥，湖中间还有鸳鸯之类的。也可以选择绕小岛环行一周，30元/人 情人树 其实就是一颗普通的树，不过可以在附近拍一下不同方向的泸沽湖。 金沙江这里说的金沙江是从丽江到泸沽湖的丽宁公路段，这一段路的金沙江水是那种碧绿的颜色，像是大大的绿宝石，美不胜收。丽宁公路很多地方都是那种从山顶一直走之字型往下的路线，所以从车窗往外看就是悬崖，看着有点腿软。其实可以想象以前如果没有这条路，可能金沙江两岸山头的两户人家会老死不相往来。难以想象的是修建这条路到底付出了多大的代价，包括人力，物力，甚至是很多生命。 不过也正是有了丽宁公路，才有了泸沽湖的发展，以前从丽江到泸沽湖需要七八个小时的车程，现在只需要三四个小时。 泸沽湖观景台大概十一点多来到了泸沽湖观景台，这里可以鸟瞰整个泸沽湖。在这里看的时候其实没什么感觉，因为云南的天，云南的湖都是一样的碧水蓝天，看多了会觉得千篇一律。 呆了几分钟以后就到停车的地方坐着休息，然后等其他团员上车出发。 午餐午餐一般般，只有一只本地的烤鸡稍微好吃点，另外每桌会有两瓶酒，一瓶是男士喝的，味重，一瓶女士喝的，基本上没有酒味。大概十来个菜吧，还有一个哈掉的肥腊肉。 泸沽湖 &amp;&amp; 猪槽船午餐完就是到乘坐猪槽船的地方了，路边有卖喂食海鸥的面包的本地人，后面坐船的时候如果扔面包会有很多海鸥过来抢食，边还有散养的鸡。 来到岸边大家排队登船，一个船可以坐八个游客，外加船头两名划船的船夫，以及船尾一名掌管方向的船夫。出发往湖中小岛划去的时候船夫会介绍泸沽湖的景点，比如说女神山，还有四川和云南的交界处，其他等等。大家只用穿好救生衣（救生衣上面是有编号的，代表船号，往返都智能乘坐同一个船），坐在床上即可，也可以投食海鸥，这样子就可以近距离的拍摄海鸥了。划到中间的时候，船夫会问大家需不需要划船环岛（30元/人，感觉还是可以的），如果不需要的话就送到岛的登陆处，需要的话就带大家绕行一周。这个时候如果不愿意的话就可以叫船夫先送到小岛，然后让其他愿意的人环岛。我们选择了环岛，环岛的这一段水的可见度特别好，来到四川云南交界处的时候还喝了几口泸沽湖的水，不知道会不会像西游记里面说的一样怀孕，哈哈。这一段可选的路程，感觉30元还是蛮不错的。 环行小岛一周以后，大家来到登陆小岛的地方上岸，岛上有一个小小的寺庙，寺庙外面是一圈的转经筒。顺时钟转了一圈以后边上是一个挂满了许愿牌的地方，我们拍了一会照片就下岛乘船返回了。 返回以后很多人还没有回来，然后我们又找了一个人少一点的地方去继续伟大的拍照事业。等到大家人齐了以后我们开始出发去下一站，有点忘记晚上吃的是什么了。用完餐去了本地的酒店入住，里面有空调，不过泸沽湖的晚上还是蛮冷的。 篝火晚会七点二十的时候导游带我们去了本地的篝火晚会，门票好像是30元每人。进门的时候又是常规操作献哈达拍照（打印的照片收费20元/人），不过这个一点都不走心，哈达就是随便扔，而且拍照还拍眯眼了。 邀请了一男一女两位游客去点火，然后就是一群摩梭族的阿哥阿妹围着篝火跳本地的特色舞蹈，跳了一会就邀请大家上去跟着一起跳。说是阿哥阿妹，其实好多都是大妈。据说是因为很多游客听说了本地的习俗以后喜欢去挠手心，所以年轻的都不去了。 我们呆了一小会觉得冷就返回酒店休息了。 day7（2018-12-21 周五）摩梭家访-丽江-大理今天是返程回丽江，上午就一个摩梭家访，其实就是一个卖银饰品的推荐会顺带讲一些本地的风土人情。 草海&amp;&amp;走婚桥 草海是一块很大的湿地，算是一个很漂亮的地方，不过我们去的季节草都枯萎了，走婚桥就在草海的边上。 摩梭家访 听当地的风土人情，大型银饰品推销会。 草海&amp;&amp;走婚桥早上在酒店用完餐以后大家出发到了草海和走婚桥，早上的泸沽湖还是蛮冷的，大家下车冻的直哆嗦。 照例就是拍照，拍照，拍照。据说走婚桥是不能一次走到头的，寓意是走到头了。我们走上去感觉也没什么特别的就找了个人少的地方拍照。路边有本地人在卖苹果，核桃，苹果才5元一斤，比深圳便宜多了，我们顺便买了两个。上车吃的时候发现很甜，后悔没有多买几个。 摩梭家访摩梭家访应该是一个比较有名的浏览行程吧，我看几乎是每个团基本上都会去，可能是因为政策性扶持吧。 从草海出发以后到摩梭家访的村子，据说这里有很多这样子的村落，大家轮流接待，然后每个村子挑选出来人接待。 到了村口以后有两个本地的阿妹在等着接大家去家里，然后团里分成两组分别跟这他们过去。到达他们家里祖母房以后就开始讲解，大意如下： 不能踩门槛，门槛代表佛祖的肩膀，左脚先跨过去。 摩梭族孩子了13岁会有一个成人礼，比较郑重。 摩梭族生孩子是站着生的。 摩梭族孩子需要生下来是健康的，且会放在祖母房一个晚上，如果熬不过就熬不过。熬过了才能或者走出祖母房。 高原发烧超过二十分钟很有可能烧坏脑子，摩梭族有很厉害的退烧方法。 摩梭族给祖母和孩子都是用的银碗，可以杀毒之类的。 摩梭族的祖母房的进门右边的高台是给喇嘛活佛坐的，旁边的小门是人死了以后暂存尸体的。 摩梭族实行火葬，不保留骨灰，火葬的时间由喇嘛活佛算的。 拿银的梳子刮你的化妆品，手什么的，告诉你有毒，可以买个银饰去鉴别。 。。。。。。。。 讲完以后就带去村上的银饰店呆着，银子16.8~22.8元/克不等，不知真假，看网上有人说里面刮开是黄铜色的也有。总的来说建议去正规的地方买吧，没必要在那里购买。 午餐从摩梭家访出来以后继续出发，路上用餐非常一般，最搞笑的是两位回族的朋友只能吃泡面，想想也是惨。 吃完饭，在边上又买了一个苹果，一个梨，味道不错，就是皮有点厚。呆了一会以后大家乘车继续往丽江走，果不其然，路上又有一个专门洗车的地方。中间导游有推销牛肉干，先是拿了一些给大家品尝，试了以后感觉味道不错就买了一包400克/100元。 到达丽江以后快五点，吃了一碗面以后打车去到丽江古城南面的丽江客运站乘车去往大理古城。从丽江客运站买票去到下关（84元/人加保险），中间是经过大理古城的，开始一直还不知道。 晚餐两个多小时达到大理古城后，直奔酒店，放下行李以后就出来开始继续逛大理古城找吃的。这次我们在人民路转了十多分钟就放弃了，真的是没什么吃的，一度想去中间的金拱门用餐。返回东门主干道那条路的时候路边已经有很多小摊了，有一个烧烤店人挺多的，我们就坐下点了一些菜，味道还真不错。吃完在边上再买了一些煎饺返回酒店吃，老板现包的，味道也很好。 day8（2018-12-22 周六）洱海环游-摘草莓因为早上想去洱海看日出，所以我们昨晚租了一个八点送到的电动车，还是在前面那个店租的。不过运气不好的是这个车好像有点问题，有电的时候也显示要充电，估计是天太冷了。 骑上摩托车以后先到了才村码头，在这里如果来的早或者晚就不会需要游船票进来，刚好看到日出的时候，其实一般般，因为洱海就一点点大，没什么特别的。呆了一小会出发去吃了个早餐，油条，豆浆，鸡蛋，稀饭。 吃完早餐以后出发洱海骑行，由于上次是往北边的喜洲骑的，这次我们往南边下关方向骑。结果一路上很少有海边的景色，都是很多民居，所以如果骑行建议大家还是往北边走。早上骑车是真的冷，一路上一直在想，自己到底怎么想不通为啥要大冬天早上来骑摩托车。不过比较幸运的是我们找到了几个人少，而且特别漂亮的地方拍照。其实骑车没有骑多远，主要时间就花在拍照上面了。 大概到了11:20，在我的再三催促下老婆大人才恋恋不舍的坐上摩托车返程，中午太阳强一些以后骑车舒服多了，所以大家冬天如果在洱海骑车建议就从大理古城往喜洲方向骑，四点之前要返程，要不晚上也太冷了。 骑车返回大理古城的时候老婆提议去采摘草莓，想想这大好的天气，确实可以采一下草莓。从大理古城到才村码头路上有很多可以采草莓的地方，随便找了家问了一下25元/斤，价格很不错，比很多地方都便宜。看了一下地里的草莓，很多都熟透了，走在中间都能闻到很浓的香味，应该是很好吃。我们挑了一些熟的，个头不是很大的草莓，顺便拍了个小视频优化大舅哥家的小侄女。 采完草莓以后骑车继续往大理古城走，我们实在是想不到吃什么东西就打算去人民路吃金拱门了。骑车过去的时候路过洋人街有挺多的云南樱花，特别漂亮。在金拱门点了个套餐吃完后返回客栈拿了行李乘坐8路车前往大理火车站，只花了40分钟就到了。 从大理火车站到昆明火车站两个小时，这次买的是二等座145元/人。五点多一点到达昆明火车站以后，由于我们预约了从昆明火车站到昆明长水机场的接机服务，但是接机的司机堵车堵了好久一直到六点十分才过来，中间等的时间太长了，我们就在边上吃了点零食，然后逛了一下超市。 六点十分司机过来接我们以后大概花了三十多分钟就从昆明火车站到了长水机场，比转乘地铁快很多。这一天刚好是冬至，农历十六，窗外的月亮特别圆，而且比在低海拔地区看到的更大，再加上云南的天比较干净，看得特别清晰。 晚上十点五十左右到达深圳，刚好快赶上末班地铁了，一路顺顺利利的到家了。此行八天七夜的云南之行圆满结束。]]></content>
      <tags>
        <tag>走四方</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-使用nginx部署]]></title>
    <url>%2F2018%2F12%2F13%2Fhexo-%E4%BD%BF%E7%94%A8nginx%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[通常使用hexo在本地调试运行的时候我们运行hexo s即可，如果我们想要部署博客供人访问的时候就要采用别的方式了。我这里选择的是使用nginx部署： 安装nginx安装nginx可以参考菜鸟教程 使用nginx配置hexo1234location / &#123; root /usr/local/blog/jacentsao.github.io/.deploy_git; index index.html index.htm;&#125; 获取auto_certbot（2019-03-22更新）12wget https://dl.eff.org/certbot-autochmod a+x certbot-auto 安装证书1./certbot-auto certonly --standalone --email admin@example.com -d example.com -d www.example.com -d other.example.net 获得免费的https证书–废弃123456$ yum install epel-release$ yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional$ yum install python2-certbot-nginx$ yum install -y certbot//获取证书$ certbot certonly --standalone -d example.com --agree-tos --email yourmail 配置nginx12345678server &#123; listen 80; server_name localhost; listen 443 ssl; ssl_certificate /etc/letsencrypt/live/yourdomain/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/yourdomain/privkey.pem; .....&#125; 自动更新证书12//自动刷新证书（证书有效期90天）--废弃$ 10 1 * */2 * certbot renew --pre-hook "systemctl stop nginx" --post-hook "systemctl start nginx" 12# 使用certbot-auto更新10 1 * */2 * /root/certbot-auto renew --pre-hook "systemctl stop nginx" --post-hook "systemctl start nginx"]]></content>
      <categories>
        <category>博客编写</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自由行-搭建ss服务器]]></title>
    <url>%2F2018%2F12%2F12%2F%E8%87%AA%E7%94%B1%E8%A1%8C-%E6%90%AD%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[详细安装配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940$ cd /etc/yum.repos.d/$ curl -O https://copr.fedorainfracloud.org/coprs/librehat/shadowsocks/repo/epel-7/librehat-shadowsocks-epel-7.repo$ yum install -y shadowsocks-libev$ curl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"$ python get-pip.py$ pip install --upgrade pip//修改配置，主要是设置端口和密码$ vim /etc/shadowsocks.json &#123; "server": "0.0.0.0", "local_address": "127.0.0.1", "local_port": 1080, "port_password": &#123; "26888": "yourpassword", "26889": "yourpassword" &#125;, "timeout": 600, "method": "aes-256-cfb" &#125;//添加ss系统服务$ vim /etc/systemd/system/shadowsocks.service [Unit] Description=Shadowsocks [Service] TimeoutStartSec=0 ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json [Install] WantedBy=multi-user.target//启动ss服务 $ systemctl enable shadowsocks]]></content>
      <categories>
        <category>自由行</category>
      </categories>
      <tags>
        <tag>自由行</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - 搭建RocketMQ开发环境]]></title>
    <url>%2F2018%2F12%2F04%2FJava-%E6%90%AD%E5%BB%BARocketMQ%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[今天尝试搭建一下RocketMQ开发环境，特此记录下搭建流程和搭建过程中遇到的一些问题。 首先根据官网的教程搭建。 快速启动环境准备 64bit OS, Linux/Unix/Mac is recommended; 64bit JDK 1.8+; Maven 3.2.x; Git; 4g+ free disk for Broker server 下载，构建下载源码或者release的版本，下载地址: https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.3.2/rocketmq-all-4.3.2-source-release.zip 如果下载的是源码的话需要使用maven进行编译： 12345 &gt; unzip rocketmq-all-4.3.2-source-release.zip&gt; cd rocketmq-all-4.3.2/&gt; mvn -Prelease-all -DskipTests clean install -U&gt; cd distribution/target/apache-rocketmq 如果不是源码的话直接进入解压后的文件即可。 启动Name Server12345&gt; nohup sh bin/mqnamesrv &amp;&gt; tail -f ~/logs/rocketmqlogs/namesrv.logThe Name Server boot success...以上是官网提供的示例。我遇到的情况是输出倒了当前目录下的nohup.out文件中，使用tail 或者vim确定Name Server是否正常启动 启动Broker1234&gt; nohup sh bin/mqbroker -n localhost:9876 &amp;&gt; tail -f ~/logs/rocketmqlogs/broker.log The broker[%s, 172.30.30.233:10911] boot success...同样的在nohub.out中查看 发送和接收消息1234567//告诉客户端需要发送到哪个服务端&gt; export NAMESRV_ADDR=localhost:9876&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.ProducerSendResult [sendStatus=SEND_OK, msgId= ...&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.ConsumerConsumeMessageThread_%d Receive New Messages: [MessageExt... 关闭服务1234567&gt; sh bin/mqshutdown brokerThe mqbroker(36695) is running...Send shutdown request to mqbroker(36695) OK&gt; sh bin/mqshutdown namesrvThe mqnamesrv(36664) is running...Send shutdown request to mqnamesrv(36664) OK 简单的示例官网地址https://rocketmq.apache.org/docs/simple-example/ 1.添加依赖由于我们使用的是maven管理工具,gradle的依赖可以参考官网。 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 2.1 发送同步消息同步消息适合于很多场景，例如重要消息的通知，SMS通知，SMS系统市场。其他都在官网，可以多多看看文档。 123456789101112131415161718192021222324public class SyncProducer &#123; public static void main(String[] args) throws Exception &#123; //Instantiate with a producer group name. DefaultMQProducer producer = new DefaultMQProducer("please_rename_unique_group_name"); // Specify name server addresses. producer.setNamesrvAddr("localhost:9876"); //Launch the instance. producer.start(); for (int i = 0; i &lt; 100; i++) &#123; //Create a message instance, specifying topic, tag and message body. Message msg = new Message("TopicTest" /* Topic */, "TagA" /* Tag */, ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */ ); //Call send message to deliver message to one of brokers. SendResult sendResult = producer.send(msg); System.out.printf("%s%n", sendResult); &#125; //Shut down once the producer instance is not longer in use. producer.shutdown(); &#125;&#125; 消费1234567891011121314151617181920212223242526272829public class Consumer &#123; public static void main(String[] args) throws InterruptedException, MQClientException &#123; // Instantiate with specified consumer group name. DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name"); // Specify name server addresses. consumer.setNamesrvAddr("localhost:9876"); // Subscribe one more more topics to consume. consumer.subscribe("TopicTest", "*"); // Register callback to execute on arrival of messages fetched from brokers. consumer.registerMessageListener(new MessageListenerConcurrently() &#123; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123; System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125; &#125;); //Launch the consumer instance. consumer.start(); System.out.printf("Consumer Started.%n"); &#125;&#125; 遇到的问题1. error=&#39;Cannot allocate memory&#39;123456789Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000005fb000000, 8589934592, 0) failed; error='Cannot allocate memory' (errno=12)## There is insufficient memory for the Java Runtime Environment to continue.# Native memory allocation (malloc) failed to allocate 8589934592 bytes for committing reserved memory.# An error report file with more information is saved as:# /usr/local/mq/rocketmq-all-4.3.2-bin-release/hs_err_pid6845.logUnrecognized VM option 'MetaspaceSize=128m'Error: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit. 将bin目录下的runbroker.sh的虚拟机配置调整如下： 1JAVA_OPT="$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn125m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m" 同样的如果nameserver有问题也要相应的进行调整。 2. Exception in thread &quot;main&quot; org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout由于RocktMQ没有绑定网卡ip导致，如果服务器有多网卡配置的时候，或者虚拟机。12345//生成配置信息echo "brokerIP1=10.2.x.x" &gt; broker.properties//broker绑定ipnohup sh bin/mqbroker -n 10.2.x.x:9876 -c ./broker.properties autoCreateTopicEnable=true &amp; 3. Unrecognized VM option &#39;MetaspaceSize=128m&#39;Java版本太低出现报错，此时需要升级到Java8，或者将该配置移除： 12Unrecognized VM option 'MetaspaceSize=128m'Error: Could not create the Java Virtual Machine. 移除以后即： 1JAVA_OPT="$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn125m" 4. No route info of this topic1. 请检查服务器端口是否是开放的 2. 可以试一下关闭客户端的防火墙再去请求试试。 3. 检查服务器是否有执行export NAMESRV_ADDR=localhost:9876]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-多设备之间无缝衔接]]></title>
    <url>%2F2018%2F11%2F28%2Fhexo-%E5%A4%9A%E8%AE%BE%E5%A4%87%E4%B9%8B%E9%97%B4%E6%97%A0%E7%BC%9D%E8%A1%94%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[最开始使用hexo的时候是在自己的Mac上面搭的，那时候每天都是背着自己的电脑上下班也没觉得不方便。后来老婆跟我在一起以后老是嫌弃我过安检的时候要走有包通道，非常耗时。所以就放弃了带自己的电脑上班，改为专门使用公司提供的Windows工作。这个时候就必须要把家里的电脑和公司的电脑的博客进行同步了。 安装依赖工具 安装node 123456789101112131415//下载$ wget https://nodejs.org/dist/v10.14.0/node-v10.14.0-linux-x64.tar.xz//解压$ tar xf node-v10.14.0-linux-x64.tar.xz//放到usr/local/node目录下$ mkdir /usr/local/node$ mv node-v10.14.0-linux-x64 /usr/local/node//配置环境变量$ vim ~/.zshrc$ /usr/local/node/node-v10.14.0-linux-x64/bin 添加到环境变量中$ source ~/.zshrc 刷新$ node -v 确认node是否安装ok 获取hexo博客源码将自己的博客通过各种方式获取到当前设备，比如我自己用的是git。如下所示是我的源码分支： 以下是我的生成的网页的分支： 另外再把主题单独弄一个项目进行同步。 我的做法是先拉取网页代码分支，然后进入目录以后再拉取一份切换到源码分支并改名叫.deploy_git 安装启动hexo123$ npm install -g hexo-cli$ npm install hexo --save$ hexo s --debug]]></content>
      <categories>
        <category>博客编写</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stub简介]]></title>
    <url>%2F2018%2F11%2F28%2FStub%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Stub 本意是指桩，具体含义如下： n. 存根；烟蒂；树桩；断株 vt. 踩熄；连根拔除 n. (Stub)人名；(挪、瑞典)斯图布 在计算机语言中指维基百科)。 桩[1]（Stub / Method Stub）是指用来替换一部分功能的程序段。桩程序可以用来模拟已有程序的行为（比如一个远端机器的过程）或是对将要开发的代码的一种临时替代。因此，打桩技术在程序移植、分布式计算、通用软件开发和测试中用处很大。 以下是桩程序的一个例子（伪码）： 12345678910BEGIN Temperature = ThermometerRead(Outside) IF Temperature &gt; 40 THEN PRINT &quot;It&apos;s HOT!&quot; END IFENDBEGIN ThermometerRead(Source insideOrOutside) RETURN 28END ThermometerRead 上例中的伪码调用了 ThermometerRead函数，其返回一个温度。由于ThermometerRead需要去读取硬件设备，而这个函数现在还没能开发完成，不能正常工作。ThermometerRead只是简单的返回了一个合理的值，这样主程序就能正常调用这个函数，并继续接下来的开发了。可以注意到，虽然它接受了一个Source类型的参数，表明需要返回的温度是内部还是外部的，实际上并没有对这个参数进行任何使用。 桩程序是一段并不执行任何实际功能的程序，只对接受的参数进行声明并返回一个合法值。这个返回值通常只是一个对于调用者来讲可接受的值即可。桩通常用在对一个已有接口的临时替换上，实际的接口程序在未来再对桩程序进行替换。 在远程方法调用（RMI）中将客户辅助对象称之为Stub（桩）；将服务辅助对象称之为skeleton[2]（骨架）。 RMI的过程是：客户对象一旦被调用，客户对象调用stub，stub调用网络远端的skeleton，而skeleton最终调用真正的服务对象。由此，在调用客户对象的时候，感觉上就是直接调用了真正的服务对象。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go程序设计语言(The Go Programming Language)]]></title>
    <url>%2F2018%2F07%2F23%2FGo%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-The-Go-Programming-Language%2F</url>
    <content type="text"><![CDATA[第2章 程序结构2.1 名称 Go通过首字母的大小写来决定是否包外可见，大写代表可以被包外引用，小写意味着只能包内使用 Go使用驼峰命名的方式，不使用小写+下划线的方式 Go中，名称的作用域越大，使用越长且更有意义的名称 2.2 声明 var 变量 const 常量 type 类型 func 函数 2.3 变量var 声明创建一个具体类型的变量 1var name type = expression 类型和表达式可以省略一个，省略类型自动根据表达式推导类型，省略表达式则变量取默认值（数字为0，布尔型为FALSE，字符串为””，接口和引用类型(slice、指针、map、通道、函数为nil)，数组或结构体这样的符合类型，零值是所有元素或成员的零值） 2.3.1 短变量声明123i, j := 0,1i,j = j, ii:= 1 2.3.2 指针变量是存储值的地方 指针的值是一个变量的地址。一个指针指示值所保存的位置。不是所有的值都有地址，但是所有的变量都有。使用指针可以在不知道变量名的情况下间接更新或者使用变量的值。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker安装WordPress]]></title>
    <url>%2F2018%2F05%2F31%2F%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85WordPress%2F</url>
    <content type="text"><![CDATA[下载WorldPress镜像1234567891011121314151617$ sudo docker pull wordpress:latest$ sudo docker pull mysql$ docker run --name docker-mysql -e MYSQL_ROOT_PASSWORD=KingDee@2017 -d mysql:5.7$ docker run --name docker-wordpress --link docker-mysql:mysql -p 6000:80 -d wordpress$ 安装插件：https://wordpress.org/plugins/useso-take-over-google/$ docker run -p 3306:3306 --name e-mysql -e MYSQL_ROOT_PASSWORD=10086.com -d mysql:5.7$ docker exec -it 88dab2f338c6 bash $ mysql -uroot -p -h localhost$ use mysql$ docker run -p 6379:6379 -v $PWD/data:/data -d redis:3.2 redis-server --appendonly yes$ docker exec -it b1125e1d09b8 redis-cli]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zheng项目学习]]></title>
    <url>%2F2018%2F05%2F14%2FZheng%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1. 环境配置1. 安装redisRedis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。 Windows安装从Github上面下载1https://github.com/MicrosoftArchive/redis/releases Mac安装12345678910$ brew install redisTo have launchd start redis now and restart at login: brew services start redisOr, if you don&apos;t want/need a background service you can just run: redis-server /usr/local/etc/redis.conf $ redis-cli 进入redis命令 2. 安装zookeeperZookeeper是一种分布式协调服务，用于管理大型主机。在分布式环境中协调和管理服务是一个复杂的过程，Zookeeper通过其简单的架构和API解决了这些问题。Zookeeper允许开发人员专注与核心应用程序逻辑，而不必担心应用程序的分布式特征。 分布式应用正在运行的一组系统成为集群，集群中运行的每台机器称为节点。 Macos通过brew安装12345$ brew install zookeeperTo have launchd start zookeeper now and restart at login: brew services start zookeeperOr, if you don&apos;t want/need a background service you can just run: zkServer start 从Apache官网下载下载地址： 1http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz 下载解压以后需要更改配置文件 在解压的目录下新建配置文件zoo.cfg 新增以下配置 1tickTime = 2000 dataDir = /path/to/zookeeper/data clientPort = 2181 initLimit = 5 syncLimit = 2 启动解压目录下的zkServer.sh(linux)或者zkServer.cmd(Windows) 启动解压目录下的zkCli.sh(linux)或者zkCli.cmd(Windows) 3. 安装 Apache ActiveMQ12345$ brew install apache-activemqTo have launchd start activemq now and restart at login: brew services start activemqOr, if you don&apos;t want/need a background service you can just run: activemq start 4. 安装MySQL12345678910111213$ brew install mysqlWe&apos;ve installed your MySQL database without a root password. To secure it run: mysql_secure_installationMySQL is configured to only allow connections from localhost by defaultTo connect run: mysql -urootTo have launchd start mysql now and restart at login: brew services start mysqlOr, if you don&apos;t want/need a background service you can just run: mysql.server start 5. 安装jenkins12345678Note: When using launchctl the port will be 8080.To have launchd start jenkins now and restart at login: brew services start jenkinsOr, if you don&apos;t want/need a background service you can just run: jenkins==&gt; Summary🍺 /usr/local/Cellar/jenkins/2.121: 7 files, 74.4MB, built in 42 seconds]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网部署yapi接口管理平台]]></title>
    <url>%2F2018%2F05%2F13%2F%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2yapi%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[YApi 是一个可本地部署的、打通前后端及QA的、可视化的接口管理平台，项目官网,Github地址。 本文是对自己在多平台内网部署的时候的过程及遇到的问题的记录。 内网部署环境要求 nodejs (7.6+) mongodb (2.6+) git 安装使用yapi-cli工具部署。执行yapi sever启动可视化部署程序。 升级cd {项目目录}yapi ls //查看版本号列表yapi update //更新到最新版本yapi update -v {Version} //更新到指定版本 centos安装环境安装nodejs使用EPEL安装nodejs 1234567891011$ yum info epel-release 检查是否有安装$ sudo yum install epel-release 安装epel$ sudo yum install -y nodejs 安装nodejs$ sudo npm install -g cnpm --registry=https://registry.npm.taobao.org$ sudo npm install -g n$ sudo n stable 安装最新的稳定版本 安装mongodb1 . 创建文件 1$ vim /etc/yum.repos.d/mongodb-org.repo 2 . 复制下面的内容 123456[mongodb-org-3.6]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.6/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc 国内的服务器替换 baseurl 为阿里源,否则你回感受来自共产主义的负加成 1baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/6/mongodb-org/stable/x86_64/ 我搭建的时候用的 1baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/7Server/mongodb-org/3.2/x86_64/ 下载速度很快但是每次卡在最后一步，最后把3.2版本改为3.6以后一下载就安装好了 3 . 更新文件，安装 12$ yum udpate $ yum -y install mongodb=org 配置nginx代理由于centos是丢在一台Windows机器的Vmware WorkStation上面，所以还用了nginx反向代理yapi，配置如下 123456location / &#123; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_pass http://127.0.0.1:3011; &#125; Macos安装由于开了全局代理，终端翻墙，安装过程基本按照官方教程过程很流畅。 结语做开发，一要网络好，二要代理好。感谢GCD，感谢阿里巴巴。]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java - lambda学习笔记]]></title>
    <url>%2F2018%2F04%2F10%2Fjava-lambda%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[后端性能测试1]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%90%8E%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%951%2F</url>
    <content type="text"><![CDATA[最近在做Golang上线前的准备工作，包括部署和性能测试，本次主要记录性能测试相关的内容，以免自己遗忘。 ab命令行测试(Apache Benchmark)首先想到的是简单的性能测试工具ab（Apache Benchmark），MacOS应该是自带了ab测试工具，Windows的话需要自行安装配置，可以参考一下链接。 安装好ab工具以后在终端输入ab可以看到很多参数，其中常用的参数有： -n requests 请求次数量 -c concurency 并发的请求数量 -t timelimit 请求的次数限制，默认值为-n 50000 -s timeout 请求的单次超时，默认值为30s -p postfile 发送文件中的请求，配合-T 使用 -T Content-type 默认值’text/plain’ 以下一个完整的ab测试post请求如下： -n 100 -c 10 -p ./login.txt -T 'application/json'```12即100次请求，并发数为10，指定当前目录下的login.txt文件中的json数据发送到服务器localhost，5174端口。以下是login.txt中的文件内容: {“test”:”test”,”cmd”:”test”}1234##### 测试结果分析以下是以请求百度首页模拟100人总计10000此访问来进行ab测试返回分析: ab -n 10000 -c 100 https://www.baidu.com/index.html//ApacheBenchmark软件申明This is ApacheBench, Version 2.3 &lt;$Revision: 1807734 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/ //测试的网址Benchmarking www.baidu.com (be patient) //请求的进度Completed 1000 requestsCompleted 2000 requestsCompleted 3000 requestsCompleted 4000 requestsCompleted 5000 requestsSSL handshake failed (1).140735932269448:error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22/libressl/ssl/s23_clnt.c:565:Completed 6000 requestsCompleted 7000 requestsSSL handshake failed (1).140735932269448:error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22/libressl/ssl/s23_clnt.c:565:Completed 8000 requestsCompleted 9000 requestsCompleted 10000 requestsFinished 10000 requests //百度的服务器软件信息Server Software: BWS/1.1//被测试的主机地址Server Hostname: www.baidu.com//https的默认端口Server Port: 443//加密协议SSL/TLS Protocol: TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128//加密服务器名称TLS Server Name: www.baidu.com //文档的路径Document Path: /index.html//文档的大小Document Length: 227 bytes //并发数Concurrency Level: 100//测试总的时间Time taken for tests: 146.932 seconds//完成的请求数量Complete requests: 10000//失败的次数Failed requests: 2 (Connect: 0, Receive: 0, Length: 2, Exceptions: 0)//总的数据传输量，包括请求头和文本内容Total transferred: 8718256 bytes//请求的文档总大小 227 10000 （总计一万次请求）- 2 227（两次失败）HTML transferred: 2269546 bytes//每秒完成的请求数量 10000/146.932Requests per second: 68.06 [#/sec] (mean)//每个请求的平均耗时Time per request: 1469.317 [ms] (mean)//服务器完成一个请求的耗时Time per request: 14.693 [ms] (mean, across all concurrent requests)//服务器的吞吐率Transfer rate: 57.94 [Kbytes/sec] received //连接信息Connection Times (ms) min mean[+/-sd] median maxConnect: 0 1220 947.0 1170 45274Processing: 14 234 227.0 116 2292Waiting: 13 220 214.9 114 2291Total: 107 1454 961.3 1301 46006 //完成请求比例的耗时，如下完成90%的耗时为1990msPercentage of the requests served within a certain time (ms) 50% 1301 66% 1377 75% 1464 80% 1540 90% 1990 95% 2221 98% 2827 99% 2972 100% 46006 (longest request)```]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>性能</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库学习2 - 语法]]></title>
    <url>%2F2018%2F01%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A02-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础语法 如果查询的列名在用到的两个或者多个表中不重复，则对这一列的引用不用加表名限制 视图和基表数据是同步更新的，视图不能创建索引]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习笔记1]]></title>
    <url>%2F2017%2F12%2F30%2FKotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[随着Kotlin的越来越火热，对于Android开发者而言学习Kotlin也变成了一个必要的过程了。 基础语法定义一个类1class User(name: String, age: Int) &#123;&#125; //如果类没有内容则大括号可以省略掉 构造函数的函数体，即下列代码的init块中 12345class User(name: String, age: Int) &#123; init &#123; ... &#125;&#125; 类继承默认任何类都是继承基础类Any（类似于java中的Object），但是我们可以继承其它类。所有的类默认都是final的，因此如果我们要让别的类继承的话就需要声明open或者abstract关键字。 123class User(name: String, age: Int)class Max(name: String, age: Int, gender: String) : User(name, age) 如上所示，如果只有单个构造器时，需要从父类继承下来的构造器中指定需要的参数，类似于java super关键字 函数函数使用fun声明: 1234567fun add(x: Int, y: Int): Int &#123; return x + y &#125; func add(x: Int, y: Int) : Int = x+y 无返回值的函数，会返回Unit，于java中的void类似，但是Unit是一个真正的对象 构造方法和函数参数1234567toast(&quot;hell&quot;) //使用默认的Toast.LENGTH_LONGtoast(&quot;hell&quot;,Toast.LENGTH_LONG)fun toast(msg: String, length: Int = Toast.LENGTH_LONG) &#123;//执行函数默认值，避免方法重载 Toast.makeText(this,msg, length).show() &#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gomobile相关的错误处理]]></title>
    <url>%2F2017%2F12%2F19%2Fgomobile%E7%9B%B8%E5%85%B3%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[务必确认在构建非Windows包的时候，根目录下面无syso版本信息文件，否则各种各样的奇葩错误 seq_android.c:213:3: errorgo build -pkgdir123# _/var/folders/w4/75xgx41n2bb7mm3m0dxbp0d40000gn/T/gomobile-work-159245723/gomobile_bindseq_android.c:213:3: error: implicitly declaring library function &apos;memcpy&apos; with type &apos;void *(void *, const void *, unsigned long)&apos; [-Werror,-Wimplicit-function-declaration]seq_android.c:213:3: note: include the header &lt;string.h&gt; or explicitly provide a declaration for &apos;memcpy&apos; 解决方案 https://github.com/golang/go/issues/22766 seq_android.c:213:3: error]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go语言实战阅读笔记2]]></title>
    <url>%2F2017%2F12%2F11%2FGo%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[Golang基础1.指针&amp;符号的意思是对变量取地址*符号的意思是对指针取值 *和 &amp; 可以互相抵消,同时注意，*&amp;可以抵消掉，但&amp;*是不可以抵消的 传指针使得多个函数能操作同一个对象。 传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。 Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针） 2.字符串` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。 3.make和new操作make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。 内建函数new本质上说跟其它语言中的同名函数功能一样：new(T) 返回的是*T，即new返回指针 内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。 流程和函数go里面没有类似于c和java的三木运算符，其主要运算符包括for、switch、if、while、goto go里面支持可变参数func name(arg …name){}]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言实战阅读笔记1]]></title>
    <url>%2F2017%2F12%2F11%2FGo%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[1.1 Go语言的特性1.1.1 高效的开发速度和编译速度Golang编译没有从编译代码到执行代码的中间过程，用动态语言编写应用程序可以快速看到输出。代价是，动态语言不提供静态语言提供的类型安全特性，不得不大量使用测试套件来避免在运行的时候出现类型错误这类bug 1.1.2 天然的并发支持1.1.2.1 goroutine不同于java和C需要编写大量额外的代码来使用线程，Golang在同一个线程中并行多个goroutine，net/http库直接使用了内置的goroutine，每个接收到的请求都在自己的goroutine中运行。goroutine使用的内存相对于线程而言更少，Go语言在运行时会自动在配置的一组逻辑处理器上调度执行goroutine。每个逻辑处理器绑定到一个操作系统上。这样子让用户的应用程序执行效率更高，而开发工作量显著减少。 1.1.2.1 通道通道是一种在goroutine中进行安全的数据通信的数据结构，帮助用户避免其它语言里面常见的共享内存访问的问题 并发最难得部分就是要确保其他并发运行的进行、线程或goroutine不会以外修改用户的数据。在线程不安全的情况下访问和修改共享变量往往会带来灾难性的后果，在其它语言中，通常要通过复杂的锁规则来防止对一个全局变量或者共享内存造成不同步的修改]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库学习1]]></title>
    <url>%2F2017%2F12%2F01%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[使用Navicat连接Mamp Pro 新建mysql连接 输入端口号，用户名和密码（默认都是root） use socket，打勾。输入/Applications/MAMP/tmp/mysql/mysql.sock 使用命令行操作mysql 执行 /Applications/MAMP/Library/bin 目录下的mysql即可进入命令行操作界面 使用golang连接数据库 db, err := sql.Open(&quot;mysql&quot;, &quot;root:root@unix(/Applications/MAMP/tmp/mysql/mysql.sock)/mysql&quot;)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh使用之文件拷贝]]></title>
    <url>%2F2017%2F11%2F30%2Fssh%E4%BD%BF%E7%94%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[最近想学习一下Golang,自己买了一个188一年的京东云服务器，准备丢点东西上去，过程实在是各种折腾，门外汉的痛苦。 ssh传输文件上传文件 scp /path/filename username@servername:/path 下载文件 scp username@servername:/path/filename /var/www/local_dir（本地目录） 下载目录 scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录） 上传目录 scp -r local_dir username@servername:remote_dir]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-基础-FileProvider使用]]></title>
    <url>%2F2017%2F10%2F27%2FAndroid-%E5%9F%BA%E7%A1%80-FileProvider%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[移动平台对于安全和隐私是越来越注重了，Android在权限方面也在不断的收紧，一定程度上对于流氓软件还是有克制作用的。 今天学习了一下FileProvider和文档)的基本使用： 1.定义Provider首先要在MManifest文件中定义一个Provider，其中authorities=包名.fileprovider。 12345678910111213141516&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapp&quot;&gt; &lt;application ...&gt; &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;com.example.myapp.fileprovider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/filepaths&quot; /&gt; &lt;/provider&gt; ... &lt;/application&gt;&lt;/manifest&gt; 2.创建filepaths文件在res目录下面新建一个xml目录，并在新建的xml目录下面创建一个filepaths的文件，内容如下所示： 1234&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;files-path name=&quot;my_images&quot; path=&quot;images/&quot;/&gt; ...&lt;/paths&gt; 定义的路径又分为如下几种，分别对应内部存储和外部存储 12345&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; Context.getFilesDir().&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; getCacheDir().&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt; Environment.getExternalStorageDirectory().&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;Context#getExternalFilesDir(String) Context.getExternalFilesDir(null).&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; Context.getExternalCacheDir(). 其中，name是出于安全考虑用于替换path显示的，path则是真实的次级目录 3.创建一个可分享的Uri123File imagePath = new File(Context.getFilesDir(), &quot;images&quot;);File newFile = new File(imagePath, &quot;default_image.jpg&quot;);Uri contentUri = FileProvider.getUriForFile(getContext(), &quot;com.mydomain.fileprovider&quot;, newFile); 最终获取到的Uri是content://com.mydomain.fileprovider/my_images/default_image.jpg，可以看到实际的images路径被替换为my_images了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FileProdvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 代理设置]]></title>
    <url>%2F2017%2F10%2F22%2FAndroid-Studio-%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近因为Lantern老是出问题，又买了一个搬瓦工的，搭建好后速度还是可以的，Youtube上面1080P没有卡顿现象。但是各种工具的是使用又出现了问题，所以特意记录一下，节省下次切换工具配置的时间。 git配置首先是配置git的代理，以下是http(s)配置 123456git config --global https.proxy &apos;http://127.0.0.1:65322&apos;git config --global http.proxy &apos;http://127.0.0.1:65322&apos;取消设置代理git config --global --unset http.proxygit config --global --unset https.proxy 12export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087; Gradle配置在全局的gradle.properties中添加以下配置，这样子每个项目的gradle同步都回使用ss代理了。 1234systemProp.http.proxyHost=127.0.0.1systemProp.http.proxyPort=1087systemProp.https.proxyHost=127.0.0.1systemProp.https.proxyPort=1087 Android Studio代理设置目前来看启用自动代理即可]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh免登录]]></title>
    <url>%2F2017%2F10%2F22%2Fssh%E5%85%8D%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[基本知识Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。 平时我们会通过ssh远程登录我们的主机来进行管理，在Mac下面一般我会通过自带的Terminal或者iterm2直接登录，而在Windows下面的话通常会使用Putty进行登录。 登录流程12345678910基本登录ssh user@host (用户名+主机地址)如果本机用户名跟远程的主机用户名一致，可以省略掉用户ssh hostssh默认端口是22，如果端口不是默认值则需要指定端口登录ssh user@host -p 1111 指定端口1111，使用用户user登录到主机在输入完上面的指令以后接下来就是输入密码了，此处就不再累述了 公钥登录在上面的流程中，我们每次都需要重新输入密码才能够进行登录，那么可不可以免密码直接登录了，答案当然是可以的了。 通过公钥登录可以实现免密码登录，首先在客户端生成一对公钥私钥，然后将公钥添加到远程主机的12具体流程如下： 在客户端生成一对公钥私钥 ssh-keygen这个时候在目录~/.ssh/下面就会生成id_rsa.pub（公钥），id_rsa（私钥） 将公钥拷贝到远程主机 ssh-copy-id user@host``` 经过上述流程我们就实现了ssh免密码登录的流程了。]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 性能优化第五季]]></title>
    <url>%2F2017%2F09%2F12%2FAndroid-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%AC%E4%BA%94%E5%AD%A3%2F</url>
    <content type="text"><![CDATA[Android Performance Pattern Season 51. Thread PerformanceThe main process(UI Thread) does this: System Events Input Events Application Service Alarm UI Drawing If there is a large chunk of work between an input event and its callback, then the user will have to wait a longer than expected to see results. If render is not finished in 16ms(60frame/s), and it will cause dropped frame. So android provide lot of solution to this heavy task: AsyncTask support serial single progress and parallel on a pool of threads managed by AsyncTask HandlerThread ThreadPool]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 通过hierarchy View来分析布局]]></title>
    <url>%2F2017%2F08%2F28%2FAndroid-%E9%80%9A%E8%BF%87hierarchy-View%E6%9D%A5%E5%88%86%E6%9E%90%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Hierarchy Viewer是Android device monitor内嵌的一个工具，可以通过这个工具来检查你的层次视图的属性和Layout的速度。他能够帮你找到层次布局结构的性能瓶颈，帮助你简化层次布局减少过度绘制。 开始如果使用Android模拟器的话可以略过这一段。否则的话，需要对你的设备进行如下的配置： 注意：你的设备需要时Android4.1及以上API版本 打开设备的开发者模式 在你的开发电脑上设置环境变ANDROID_HVPROTO=ddm，这个变量告诉Hierarchy Viewer使用和DDMS协议一致的ddm协议来连接你的设备。但是host只能够有一个进程连接到设备，所以你必须关闭其他通过Hierarchy Viewer运行的DDMS会话 开始使用Hierarchy Viewer打开Android device monitor后如下图所示： 连接你的设备到电脑。 打开Android Studio，运行一个软件到你的设备 在Android Studio-Tools-Android-Android device monitor。 选择Hierarchy View 在左边的窗口双击你的包名。 熟悉工具下图是Hierarchy Viewer的面板:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Performance and View Hierarchies]]></title>
    <url>%2F2017%2F08%2F27%2FAndroid-Performance-and-View-Hierarchies%2F</url>
    <content type="text"><![CDATA[布局的层次对于应用的性能影响也是很显著的。 布局和测量性能渲染本身包含了Layout和Measure两个过程，系统在这两个过程中确定View hierarchy的具体位置。Measure过程确定了View的尺寸和边界，Layout过程则确定了View在屏幕的位置。 这两个过程本身会占用一些系统的资源。当然，大多数时候，这个过程占用的系统资源较少，不会对性能造成显著的影响。但是，如果你的应用需要添加或者移除View对象就会显著开销更多的资源，例如Recycleview回收或者复用。或者当一个View对象需要重绘来满足它的约束的时候，也会占用更多的资源。例如，给一个WRAP_CONTENT的View对象设置文本，会导致重绘。 如果一个渲染过程过长，就会导致无法在16ms内渲染完一帧，这就会导致掉帧，动画也会变得卡顿。 由于UI的绘制是处于主线程的，所以对于这些导致卡顿的问题需要优化，从而让我们的应用变得流畅。 管理复杂度：Layout相关Android布局允许你嵌套UI对象，这种嵌套经常会导致额外的开销。当你的应用渲染一个Layout的对象，应用同时需要渲染它的所有的子View。对于一个复杂的Layout，有时候系统只有在第一次加载的时候会比较占用系统资源。例如，你的应用中有一个复杂的复用过的Recycleview，系统需要加载所有的对象。其他例子，一个微不足道的变化可能会导致视图层次的一系列的重绘。 Layout过程中视图层次的嵌套会显著导致绘制的时间增加。因此，越少层次的嵌套，Layout过程花费的时间就越少。 如果你使用RelativeLayout，但是你也可能在不使用weight属性的情况下，通过使用LinearLayout实现。另外，如果你的target版本是Android7.0的话，你还可以使用ConstraintLayout，这是一个用于替换RelativeLayout的布局，它是一个功能类似，性能更好的RelativeLayout。 “双重税收”一般来说，系统执行Layout或者Measure过程是非常快的。但是，对于一些很复杂的Layout，系统可能需要多次绘制才能够最终确定所有对象的位置。这种超过一次的Layout和Measure过程就是所谓的双重税收。 例如，当你使用一个可以通过一个View对象确定另一个View对象的位置的RelativeLayout容器。系统会执行以下步骤： 根据每一个子View的约束条件，逐个执行Layout和Measure过程 使用前面的数据，同时计算View的weight，来给相对的View找到一个合适的位置 再次执行Layout过程来确定这些相对位置的View 执行下一个渲染过程 如果你的视图层次越多，那么潜在性能问题就越多。 除了RelativeLayout其他容器也会导致双重税收。例如： 水平的线性布局会导致两次Layout和Measure过程。如果你给线性布局添加了measureWithLargestChild（其实是由于使用了weight属性的View的尺寸等于最大的子View的最小尺寸）也有可能由于要进行第二次Layout和Measure来确定每一个View对象的大小。 GridLayout同样也有类似的问题。这个容器同样允许相对位置，正常情况下，GridLayout会通过预处理确定号子View的相对关系来避免双重税收。但是，如果Layout使用了weight或者Gravity的时候，它的预处理就没了，当容器是RelativeLayout的时候系统可能需要多次执行这个过程。 多次的Layout和Measure过程本身并不是一个性能负担。但是，他们会在某些场景下成为一种负担。我们应该对以下的情况保持足够的警惕： 布局层次的根布局 布局层次过多 一个界面产生很多的实例，例如ListView 诊断布局层次问题布局性能问题受到很多因素的影响而变成了一个复杂的问题。以下是一些帮助你找到性能瓶颈的工具。当然也有一些其他的，没有那么确定性的工具，但也能提供一些提示帮助我们找到问题。 SystraceSystrace是一个Android SDK内嵌的诊断性能问题的工具。这个工具允许我们查看整个设备的时间信息，允许你查看什么时候会因为Layout的性能问题影响到设备的性能。 GPU呈现模式lint检查Hierarchy Viewer解决布局层次问题减少无用的嵌套使用merge/include标签整体替换新的Layout]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-性能优化-overdraw]]></title>
    <url>%2F2017%2F08%2F22%2FAndroid-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-overdraw%2F</url>
    <content type="text"><![CDATA[现在项目的性能之差令人发指，其实主要原因在于： 开发人员本身能力有限，同时架构闻所未闻，见所未见。总而言之，搞不定。 产品设计从来都是乱搞，没有整体性的设计(感觉我们的app真是业界毒瘤之典范) 不过，我们还是要把能做好的做好了才行。 性能优化-OverDraw所谓overdraw(过度绘制)就是在一个点上进行了超过一次的绘制。过渡绘制是无意义的，需要我们去优化的，它会浪费GPU资源去渲染一些用户不可见的无意义的图层。关于如何查看过渡绘制，应该都是有所了解的。接下来是关于过度绘制：过度绘制是什么，怎么诊断过度绘制，你该采取何种方式取消除或者减轻过渡绘制。 理解过度绘制过渡绘制指的是系统在一个像素点是那个进行了多次的渲染。例如，我们一些堆叠的UI卡片，每一张卡片又隐藏了它的一部分。 当然，系统仍然需要绘制这叠卡片的隐藏部分，因为卡片的绘制是根据画家算法（“画家算法”表示头脑简单的画家首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分。）。这就是从下到上的顺序。这种渲染顺序允许系统增加合适的透明度给半透明的物体，例如阴影。 查找过度绘制Android提供了几种工具帮助你查找影响到你的app性能的过度绘制。这些工具在你的设备上打开开发者模式就可以找到。关于更多开发者选项，可以参见Run Apps on a Hardware Device。 调试GPU过度绘制工具调试GPU过度绘制工具使用颜色来代表你的应用在一个像素点上渲染的次数。渲染次数越多，过度绘制就越会影响你的应用性能。 关于如何使用这些工具，请继续往下看： 调试GPU过度绘制查验这种检查方法是通过颜色来形象化手机中的过度绘制，有如下好处： 显现出应用做了哪些无用的渲染工作 帮助你找到可能能够减少渲染的天花板 在开发者选项 - 调试GPU过度绘制 - 选用显示过度绘制区域，然后回到你的应用，这时候你看到的颜色 原色：没有过度绘制 蓝色：一次过度绘制 绿色： 两次过度绘制 粉红色： 三次过度绘制 红色：四次或者四次以上的过度绘制 有时候过度绘制是不可避免的。当你调试你的UI的时候，你的界面应该尽量是原色或者蓝色。 GPU呈现模式分析GPU呈现模式会在屏幕显示一个滚动的柱状图，每一个长方形都代表一帧的绘制 在一些低性能的GPU设备上，GPU填满帧缓存区的速度会变得很慢。当很多像素需要绘制的时候，GPU需要花很长的时间来执行新的命令，这就会导致系统对于其它的请求反应变得很慢。 优化过度绘制 减少不必要的背景 扁平化布局，减少布局的层次 少使用transparency属性 减少不必要的背景布局本身是没有背景的，这就意味着他本身并不需要渲染背景。当布局本身有了背景以后，就意味着她可能会导致过度绘制。 移除不必要的背景是一种快速修复渲染问题的手段。当绘制的背景对于用户来说完全不可见的时候就可以取移除掉这些背景了。例如一个设置了背景色的app，那么定义在Activity中的任意一个容易本身是不需要背景的。 如果需要知道为什么你的app会出现过度绘制，你可以使用Hierarchy View工具。当你使用这个工具的时候，消除所有对于用户不可见的背景。当然，我们可以通过设置一个通用的背景来达到消除不必要的背景的目的，这样子绘制的容器就可以不再定义自己的背景而使用app的通用背景（windowbackgroud）。 减少布局的层次不局的过多嵌套同样也会导致过度绘制，同时也会因为节点过深导致视图的加载变慢。我们应该减少UI的重叠绘制，详情参见Optimizing View Hierarchies 使用transparency使用Alpha值的时候，同捕鱼常规的过度绘制即在同一像素点多次绘制，transparent属性的对象首先需要已经存在的像素进行绘制，然后进行等价的混合。例如，一个黑色字体的TextView通过添加Alpha值来达到灰色的效果，当然这个时候可以直接使用灰色来替换。 transparent animations, fade-outs, 以及 drop shadows以及其他的半透明效果，都会显著导致过度绘制。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-常用命令]]></title>
    <url>%2F2017%2F08%2F07%2Fgit-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[开始 git clone http://xx/zhj_android.git 添加.gitignore到根目录，参考资料 git add .gitignore 添加该文件到版本控制，提交到暂存区 git commit -m “add .gitignore file” 从暂存区提交到当前分支 git push 提交到远程仓库 常用的git命令 git rm -r xx 从版本控制中移除xx目录及子目录 rm -rf xx 如果xx中还有git的子模块，需要使用该命令删除 git reset –hard HEAD 重置未提交的记录到HEAD Version，HEAD^回滚到上个版本,HEAD^^上上个版本，依次类推，或者指定回退HEAD~xx,xx个版本,或者指定log 提交的id git init 初始化一个目录为git仓库 git status 查看仓库状态 git diff 查看变更，同时也可以指定xx文件或者目录 git add xx 添加xx到git版本控制，每一次修改文件以后都需要添加到版本控制系统 git commit -m “xx” 提交到本地仓库，提交信息为xx (每次修改，如果不add到暂存区，那就不会加入到commit中。) git log 查看提交日志 git log –pretty=oneline git log的美化版 git reflog 查看每一次的git提交命令 git checkout -b branchname 新建分支 git checkout branchname 切换到分支 git branch 列举所有分支，带*号的为当前都在分支，加上 -r参数则是列举的远程分支 git merge branchname 合并分支到当前分支，合并模式有FAST_FORWARD 无冲突自动合并， git branch -d branchname 删除分支 git log –pretty=oneline –abbrev-commit git tag v0.9 6224937 git push origin v5.0.1 创建远程tag或者分支，前提是这个要存在 git checkout – xxx 回滚xxx git remote add origin http://192.168.204.42/ZHJ/zhj_kernel.git 添加远程 暂存当前更改 git stash 存储 git stash list 存储列表 git stash apply 取出存储的内容不删除缓存 git stash pop 去除存储的内容并删除缓存 git stash clear 清除所有的存储内容 合并指定commit git cherry-pick log-hash]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-导入Sample Code]]></title>
    <url>%2F2017%2F07%2F19%2FAndroid-%E5%AF%BC%E5%85%A5Sample-Code%2F</url>
    <content type="text"><![CDATA[Android Studio提供了很多的模板和sample用于提升我们的开发速度，如何利用好这些工具来提升我们的开发效率就是一个很值得学习的问题了。 导入Sample Code 选择File &gt; New &gt; Import Sample 使用搜索框查找你想要的内容,如下图所示： 选择你想要的内容，选中点击next &gt; finish 注意由于总所周知的问题，我们在第一步的时候可能会出现找不到资源的问题，这个时候我们就需要在翻墙的情况下设置Android Studio的代理了。 Preference &gt; Appearance &amp; Behavior &gt; System Setting &gt; Http Proxy &gt; Auto-detect proxy settings勾选即可，下方的URL无需勾选和填写。这里是我的lantern推荐码 Use my code MFST5N and get 3 months free when you sign up!]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-通过不同的res目录指定不同的资源文件]]></title>
    <url>%2F2017%2F07%2F19%2FAndroid-%E9%80%9A%E8%BF%87%E4%B8%8D%E5%90%8C%E7%9A%84res%E7%9B%AE%E5%BD%95%E6%8C%87%E5%AE%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在Android开发中，我们可能会遇到针对不同的版本进行不同的配置，比如说使用不同的资源文件。官网传送门。 自定义资源文件夹路径默认的资源文件实在 例如：main的资源文件就在src/main/res/目录下。12不过我们也可以通过自定义的方式指定资源文件目录，如下所示： android { sourceSets { main { res.srcDirs = [&apos;resources/main&apos;] } debug { res.srcDirs = [&apos;resources/debug&apos;] } } } 12当然我们也可以指定多个资源文件目录： android { sourceSets { main { res.srcDirs = [&apos;resources/main&apos;, &apos;resources/test&apos;] } debug { res.srcDirs = [&apos;resources/debug&apos;] } } } ``` 不过要注意的是同时指定多个资源文件夹的时候文件不能重复，否则在后续构建合并资源文件的时候会出现重复的错误。 #####资源合并]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-应用认领---空包写入签名]]></title>
    <url>%2F2017%2F07%2F12%2FAndroid-%E5%BA%94%E7%94%A8%E8%AE%A4%E9%A2%86-%E7%A9%BA%E5%8C%85%E5%86%99%E5%85%A5%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[最近公司项目在百度进行认领，需要将自己的签名写入百度的空包上传，过程如下： 1.执行如下命令 12jarsigner -verbose -keystore appkey.keystore -signedjar sign.apk Baidu_Claim_unsigned.apk keyAlias 其中appkey.keystore：自己的签名文件，可以加上绝对路径 sign.apk：输出文件 Baidu_Claim_unsigned.apk：原始文件 keyAlias: 密玥的别名 此过程需要输入密玥的密码，然后按enter即会执行。 2.执行过程中的输出 12345678910111213Enter Passphrase for keystore:adding: META-INF/MANIFEST.MFadding: META-INF/___.SFadding: META-INF/___.RSAsigning: AndroidManifest.xmlsigning: res/drawable/ic_launcher.pngsigning: res/layout/activity_main.xmlsigning: resources.arscsigning: classes.dexjar signed.Warning:No -tsa or -tsacert is provided and this jar is not timestamped. Without a timestamp, users may not be able to validate this jar after the signer certificate&apos;s expiration date (2043-11-01) or after any future revocation date. 3.执行完毕会在当前目录生成一个新的apk，用这个apk上传即可]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天雨好大]]></title>
    <url>%2F2017%2F06%2F20%2F%E4%BB%8A%E5%A4%A9%E9%9B%A8%E5%A5%BD%E5%A4%A7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android-Google IoSched 代码阅读笔记]]></title>
    <url>%2F2017%2F06%2F19%2FAndroid-Google-IoSched-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近做项目做的越来越烦人了，可以说近一年以来基本上没什么长进，反而有所退步。以往的激情已经被业务磨灭，真的真的该重新做点什么了。人无近虑，必有远忧。一直逃不开自己的舒适区，让自己在放纵，另一方面也是担忧自己当下的技能能否适应新的环境，总而言之，真的该认真学习好好看书了。否则的话，自己会被淘汰的。 一、代码目录结构本项目是一个比较传统的目录结构(其实还是有一些向MVP方向发展了)，即根据功能点进行分包，如下所示: 1、我的日程界面组成元素：TabLayout + ViewPager + ListFragment 1.1、在Activity中的内部类标准的使用流程如下，通过弱引用的方式持有Activity，防止由于内部类持有外部类导致的内存泄露 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * If in conference day, redraw the day&apos;s UI every @&#123;link #INTERVAL_TO_REDRAW_UI&#125; ms, so * that time sensitive widgets, like &quot;now&quot;, &quot;ended&quot; and appropriate styles are updated. * * @param today the index in the conference days array that corresponds to the current day. */private void setTimerToUpdateUI(final int today) &#123; new UpdateUIRunnable(this, today, new Handler()).scheduleNextRun();&#125;boolean hasBeenDestroyed() &#123; return mDestroyed;&#125;static final class UpdateUIRunnable implements Runnable &#123; final WeakReference&lt;MyScheduleActivity&gt; weakRefToParent; final Handler handler; final int today; public UpdateUIRunnable(MyScheduleActivity activity, int today, Handler handler) &#123; weakRefToParent = new WeakReference&lt;MyScheduleActivity&gt;(activity); this.handler = handler; this.today = today; &#125; public void scheduleNextRun() &#123; handler.postDelayed(this, INTERVAL_TO_REDRAW_UI); &#125; @Override public void run() &#123; MyScheduleActivity activity = weakRefToParent.get(); if (activity == null || activity.hasBeenDestroyed()) &#123; LOGD(TAG, &quot;Ativity is not valid anymore. Stopping UI Updater&quot;); return; &#125; LOGD(TAG, &quot;Running MySchedule UI updater (now=&quot; + new Date(UIUtils.getCurrentTime(activity)) + &quot;)&quot;); if (activity.mScheduleAdapters != null &amp;&amp; activity.mScheduleAdapters.length &gt; today &amp;&amp; activity.mScheduleAdapters[today] != null) &#123; try &#123; activity.mScheduleAdapters[today].forceUpdate(); &#125; finally &#123; // schedule again this.scheduleNextRun(); &#125; &#125; &#125;&#125; 1.2、在XML文件中利用tools属性可能我们已经习惯了在编写代码的时候设置一个默认的android:text=”这是一个XXX”之类的文本用于预览，但实际上我们可以通过tools:text=”这才是正确的使用方式”，当然硬编码的方式也是错误的。首先附上官方教程，官网永远是我们学习的最佳来源。 1234567891011121314&lt;RootTag xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; &gt;&lt;TextView android:id=&quot;@+id/slot_description&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;4dp&quot; android:layout_marginEnd=&quot;8dp&quot; android:layout_marginRight=&quot;8dp&quot; android:textSize=&quot;@dimen/text_size_medium&quot; tools:text=&quot;9:00 AM - 11:30 AM / Room 1&quot; style=&quot;@style/Body1Text&quot; /&gt; &lt;/RootTag&gt; 1.2.1、tools:ignore在任何元素中使用，主要是用于lint检查的时候忽略，例如： 1&lt;string name=&quot;show_all_apps&quot; tools:ignore=&quot;MissingTranslation&gt;All&lt;/string&gt; 1.2.2、tools:targetApi在任何元素中使用，主要是用于lint检查的时候忽略，此属性和java中的注释代码@TargetAPi类似，通过这个属性你能指定元素所能运行的API版本，例如下面这个，指定了这个GridLayout只能用于API版本14以上的版本： 123&lt;GridLayout xlmns:android=&quot;http://schemas.android.com/apk/res/android&quot; xlmns:tools=&quot;http://schemas.android.com/tools&quot; tools:targetApi=&quot;14&quot;&gt; 1.2.3、tools:locale在任何元素中使用，主要是用于lint检查的时候忽略，此属性和java中的注释代码@TargetAPi类似，通过这个属性你能指定元素所能运行的API版本，例如下面这个，指定了这个GridLayout只能用于API版本14以上的版本： 123&lt;GridLayout xlmns:android=&quot;http://schemas.android.com/apk/res/android&quot; xlmns:tools=&quot;http://schemas.android.com/tools&quot; tools:targetApi=&quot;14&quot;&gt; 1.2.4、tools:instead of android在View中使用，主要是用于Android Studio layout editor，如本节开始所示。 1.2.5、tools:context在xml文件的跟布局中使用，主要是用于Android Studio layout editor，可以指定该xml文件预览时的主题以及类似于onClick属性使用QuickFix快捷生成对应方法所在的Activity。 1234&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:context=&quot;.MainAcivity&quot;/&gt; 1.2.6、tools:layout在xml文件的跟布局中使用，主要是用于Android Studio layout editor，可以指定该Fragment预览时候的布局。 12&lt;fragment android:name=&quot;com.example.master.ItemListFragment&quot; tools:layout=&quot;@layout/list_content&quot; /&gt; 1.2.7、还有更多需要去学习1.3、处理Fragment中的生命周期大家都知道，在Fragment使用过程中，有时候会出现getActivity()=null的情况，这时候就会导致NullPointException(注意：如需 Fragment 内的某个 Context 对象，可以调用 getActivity()。但要注意，请仅在片段附加到 Activity 时调用 getActivity()。如果片段尚未附加，或在其生命周期结束期间分离，则 getActivity() 将返回 null)。因此，我们可以在onAttach()的时候传入Activity，如下所示： 1234567891011public void onAttach(Activity activity) &#123; super.onAttach(activity); LOGD(TAG, &quot;Attaching to activity&quot;); mActivity = activity;&#125;@Overridepublic void onDetach() &#123; super.onDetach(); mActivity = null;&#125; 高版本API 1234567891011public void onAttach(Context context) &#123; super.onAttach(context); LOGD(TAG, &quot;Attaching to activity&quot;); mActivity = (Activity)context;&#125;@Overridepublic void onDetach() &#123; super.onDetach(); mActivity = null;&#125; 2、探索2.1、3、地图4、社交5、视频6、设置6.1、使用PreferenceFragment7、关于7.1、加载HTML资源···Html.fromHtml(getString(&lt;![CDATA[ &lt;b&gt;Google I/O 2015&lt;/b&gt;&lt;br&gt; Version %s ]]&gt;,&quot;xxx&quot;))``` 7.28、调试8.1、使用PreferenceFragment]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库语法学习]]></title>
    <url>%2F2017%2F06%2F16%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一、基本语法1. select 1 vs select * 效率区分select 1 from table;与select anycol(目的表集合中的任意一行） from table;与select from table 从作用上来说是没有差别的，都是查看是否有记录，一般是作条件查询用的。select 1 from 中的1是一常量（可以为任意数值），查到的所有行的值都是它，但从效率上来说，1&gt;anycol&gt;，因为不用查字典表。 2. 创建视图视图是一种简单的数据查询机制，不涉及数据的存储。视图的字段名称可以与select的表不一致,视图创建以后可以跟其他的业务表进行关联，也可以正常的使用group by, having 和order by 之类的语法。 1234create view products_vw(id,name,code,init_amt,init_prc,init_stock,current_stock)as select id,name,code,init_amt,init_prc,init_stock,cur_stockfrom products 那么使用视图的意义在哪里了。 2.1 数据安全在创建视图的时候将敏感数据不引入视图，这样子提供视图给终端用户使用就达到了保护数据的目的了 2.2 数据聚合数据汇总，辅助创建新表 12345678create table products_new as select * from products_vwcreate or replace products_vw (id,name,code,init_amt,init_prc,init_stock,current_stock)asselect id,name,code,init_amt,init_prc,init_stock,current_stock from products_new 2.3 隐藏复杂性2.4 连接分区数据]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>基础知识</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell学习]]></title>
    <url>%2F2017%2F06%2F05%2FShell%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[初学遇到的一些问题 Shell脚本第一行不能直接申明Shebang，第一行写备注。否则会出现：bad interpreter: bin/zsh: no such file or directory（使用zsh如上提示，使用bash则是bin/bash）]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 命令行学习]]></title>
    <url>%2F2017%2F05%2F24%2FLinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1: 别名alias 别名列表展示： alias设置： alias name=’string’ eg: alias foo=’ls -al’取消设置: unalias foo 2：I/O重定向 cat - Concatenate files /连接文件 sort - Sort lines of text /排序文件 uniq - Report or omit repeated lines /报道或省略重复行 grep - Print lines matching a pattern /打印匹配行 wc - Pring newline, word, and byte counts for each file /打印文件中的换行符，字，和字节个数 head - Output the first part of a file /输出文件开头部分 tail - Output the last part of a file /输出文件结尾部分 tee - Read from standard input and write to standard output and files /读取标准输入，写入标准输出和文件 3：echo echo - Diaplay a line of text / 显示一行文本 4：进程 sof -i tcp:port 查看端口占用，显示PID kill -9 pid 干掉占用的进程 netstat -an | grep port]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-RecyclerView学习笔记]]></title>
    <url>%2F2017%2F04%2F26%2FAndroid-RecyclerView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[####自适应高度 继承LinearLayoutManager，重写onMeasure（）方法： if (getItemCount() == 0) { setMeasuredDimension(0, 0); } else { View view = recycler.getViewForPosition(0); if (view != null) { measureChild(view, widthSpec, heightSpec); int measuredWidth = View.MeasureSpec.getSize(widthSpec); int measuredHeight = getItemCount() * view.getMeasuredHeight(); setMeasuredDimension(measuredWidth, measuredHeight); } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Read godoc from very begain]]></title>
    <url>%2F2017%2F04%2F19%2FRead-godoc-from-very-begain%2F</url>
    <content type="text"><![CDATA[This is my note of reading godoc, i’ll try hard to improve my English level, keep on moving. How to write go codeWhen using command go get, it will fetch, build, install the package from Git or Mecurial or other revision control system.]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Spinner在某些机型上面无法收到第一次回掉的监听]]></title>
    <url>%2F2017%2F04%2F08%2FAndroid-Spinner%E5%9C%A8%E6%9F%90%E4%BA%9B%E6%9C%BA%E5%9E%8B%E4%B8%8A%E9%9D%A2%E6%97%A0%E6%B3%95%E6%94%B6%E5%88%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%9E%E6%8E%89%E7%9A%84%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[最近碰到一个很奇怪的问题，同样的一组数据在不同的手机上面显示就是不一样。通过debug发现，在一些手机上，给Spinner设置默认值的时候并不会触发它的监听回掉，而在某些机型上面又是会触发的。所以需要给第一次回掉加一个flag，默认阻止第一次回掉的后续逻辑。 ​]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BUG修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Volley中出现的java.io.InterruptedIOException:thread interrupted]]></title>
    <url>%2F2017%2F04%2F08%2FAndroid-Volley%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84java-io-InterruptedIOException-thread-interrupted%2F</url>
    <content type="text"><![CDATA[最近碰到一个很奇怪的现象，就是我们的app在启东的时候第一次请求接口的时候很容易出现请求失败的现象，尤其是在清理掉缓存重新安装的时候。由于这个接口是访问的localhost，而这个localhost是我们自己在本地启用的一个服务。所以导致了我一开始就走进了一个死牛角尖，怀疑是不是这个服务没有运行起来，导致无法访问本地服务器，钻了死角。 后面通过查找资料发现，Volley在使用的时候通过RequestQueue添加一个Request是后如果再次调用了RequestQueue的start()方法就会出现这种问题。参考资料，来自stackoverflow。 public static RequestQueue newRequestQueue(Context context, HttpStack stack) { File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = &quot;volley/0&quot;; try { String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0); userAgent = packageName + &quot;/&quot; + info.versionCode; } catch (NameNotFoundException e) { } if (stack == null) { if (Build.VERSION.SDK_INT &gt;= 9) { stack = new HurlStack(); } else { // Prior to Gingerbread, HttpUrlConnection was unreliable. // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); } } Network network = new BasicNetwork(stack); RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); return queue; } ​当使用RequestQueue的Start()方法的时候，Volley会调用stop方法确保所有的请求都是停止状态。​​ public void stop() {​ if (mCacheDispatcher != null) {​ mCacheDispatcher.quit();​ }​ for (int i = 0; i &lt; mDispatchers.length; i++) {​ if (mDispatchers[i] != null) {​ mDispatchers[i].quit();​ }​ }​ } ​在stop()方法中调用了quit()方法： public void stop() { if (mCacheDispatcher != null) { mCacheDispatcher.quit(); } for (int i = 0; i &lt; mDispatchers.length; i++) { if (mDispatchers[i] != null) { mDispatchers[i].quit(); } } } ​最终我们来到了这里，这就是我们为什么会出现thread被interrupte的原因，所以我们在使用RequestQueue的时候是不能调用Start()方法的。 public void interrupt() { // Interrupt this thread before running actions so that other // threads that observe the interrupt as a result of an action // will see that this thread is in the interrupted state. nativeInterrupt(); synchronized (interruptActions) { for (int i = interruptActions.size() - 1; i &gt;= 0; i--) { interruptActions.get(i).run(); } } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BUG修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-IPC传递数据的大小限制]]></title>
    <url>%2F2017%2F04%2F08%2FAndroid-IPC%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[最近碰到一个用户在使用app的某个功能的时候老是出现闪退情况，但是又没有别的用户反馈过这个问题。所以找用户拿数据过来看了一下，借过还真是用户的数据比较特殊： 用户在A界面传递一个LIST的对象到B界面，一个正常的使用Intent携带数据的情况，结果出现了闪退的情况。通过日志发现是： android.os.TransactionTooLargeException: data parcel size 4915644 bytes 然后查阅资料发现，现在的IPC机制其实是对传递的数据有大小限制的，一般来说是1MB，而我们传递的List中有483个对象，累积下来的大小远远超过1MB，故出现了这种问题。同样的如果我们传递一个Bitmap大小超过这个限制也会出现这种问题，所以我们在开发中要注意这些问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BUG修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql学习]]></title>
    <url>%2F2017%2F03%2F20%2Fsql%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[left join是以左表为准的，right join以右表为准，inner join不以谁为准，以条件为准 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 primary key(id, name) 复合主键，所有参数一致，才认为是一个相同的主键 CREATE INDEX 语句用于在表中创建索引。在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 union all 的表必须有相同的列数，列名字可以不一致，如果缺少列的话需要补齐，比如说null as code, 0 as rece_amt]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-MVP模式学习]]></title>
    <url>%2F2017%2F03%2F17%2FAndroid-MVP%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[MVP模式是基于MVC模式在Android上面的一个变种，可以参考谷歌的官方架构项目Android-Architecture。在 MVC 模式中，Activity 应该是属于 View 这一层。而实质上，它既承担了 View，同时也包含一些 Controller 的东西在里面。这对于开发与维护来说不太友好，耦合度大高了。把 Activity 的 View 和 Controller 抽离出来就变成了 View 和 Presenter，这就是 MVP 模式。 View只负责处理视图状态Presenter处理逻辑Contract 连接View和Presenter 针对各个界面： ​ public interface BasePresenter { void subscribe(); void unsubscribe(); } public interface BaseView&lt;T&gt; { void setPresenter(T presenter); } public interface AddEditTaskContract { interface View extends BaseView&lt;Presenter&gt; { void showEmptyTaskError(); void showTasksList(); void setTitle(String title); void setDescription(String description); boolean isActive(); } interface Presenter extends BasePresenter { void saveTask(String title, String description); void populateTask(); boolean isDataMissing(); } } ​ public class AddEditTaskPresenter implements AddEditTaskContract.Presenter { @NonNull private final TasksDataSource mTasksRepository; @NonNull private final AddEditTaskContract.View mAddTaskView; @NonNull private final BaseSchedulerProvider mSchedulerProvider; @Nullable private String mTaskId; private boolean mIsDataMissing; @NonNull private CompositeSubscription mSubscriptions; /** * Creates a presenter for the add/edit view. * * @param taskId ID of the task to edit or null for a new task * @param tasksRepository a repository of data for tasks * @param addTaskView the add/edit view * @param shouldLoadDataFromRepo whether data needs to be loaded or not (for config changes) */ public AddEditTaskPresenter(@Nullable String taskId, @NonNull TasksDataSource tasksRepository, @NonNull AddEditTaskContract.View addTaskView, boolean shouldLoadDataFromRepo, @NonNull BaseSchedulerProvider schedulerProvider) { mTaskId = taskId; mTasksRepository = checkNotNull(tasksRepository); mAddTaskView = checkNotNull(addTaskView); mIsDataMissing = shouldLoadDataFromRepo; mSchedulerProvider = checkNotNull(schedulerProvider, &quot;schedulerProvider cannot be null!&quot;); mSubscriptions = new CompositeSubscription(); mAddTaskView.setPresenter(this); } @Override public void subscribe() { if (!isNewTask() &amp;&amp; mIsDataMissing) { populateTask(); } } @Override public void unsubscribe() { mSubscriptions.clear(); } @Override public void saveTask(String title, String description) { if (isNewTask()) { createTask(title, description); } else { updateTask(title, description); } } @Override public void populateTask() { if (isNewTask()) { throw new RuntimeException(&quot;populateTask() was called but task is new.&quot;); } mSubscriptions.add(mTasksRepository .getTask(mTaskId) .subscribeOn(mSchedulerProvider.computation()) .observeOn(mSchedulerProvider.ui()) .subscribe( // onNext task -&gt; { if (mAddTaskView.isActive()) { mAddTaskView.setTitle(task.getTitle()); mAddTaskView.setDescription(task.getDescription()); mIsDataMissing = false; } }, // onError __ -&gt; { if (mAddTaskView.isActive()) { mAddTaskView.showEmptyTaskError(); } })); } @Override public boolean isDataMissing() { return mIsDataMissing; } private boolean isNewTask() { return mTaskId == null; } private void createTask(String title, String description) { Task newTask = new Task(title, description); if (newTask.isEmpty()) { mAddTaskView.showEmptyTaskError(); } else { mTasksRepository.saveTask(newTask); mAddTaskView.showTasksList(); } } private void updateTask(String title, String description) { if (isNewTask()) { throw new RuntimeException(&quot;updateTask() was called but task is new.&quot;); } mTasksRepository.saveTask(new Task(title, description, mTaskId)); mAddTaskView.showTasksList(); // After an edit, go back to the list. } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Duplicate files copied in APK META-INF/LICENSE]]></title>
    <url>%2F2017%2F03%2F15%2FAndroid-Duplicate-files-copied-in-APK-META-INF-LICENSE%2F</url>
    <content type="text"><![CDATA[今天使用jackson的时候碰到了如下错误： Error:Execution failed for task &apos;:app:transformResourcesWithMergeJavaResForDebug&apos;. &gt; com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/LICENSE File1: /Users/Eveee/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-core/2.7.2/8b8310381b690e317f5f0574e9b2dd7034778b4c/jackson-core-2.7.2.jar File2: /Users/Eveee/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-annotations/2.7.0/19f42c154ffc689f40a77613bc32caeb17d744e3/jackson-annotations-2.7.0.jar File3: /Users/Eveee/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.7.2/84ffa765dd258dbab8695963c41308b054f3a1cb/jackson-databind-2.7.2.jarError:Execution failed for task &apos;:app:transformResourcesWithMergeJavaResForDebug&apos;. &gt; com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/LICENSE File1: /Users/Eveee/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-core/2.7.2/8b8310381b690e317f5f0574e9b2dd7034778b4c/jackson-core-2.7.2.jar File2: /Users/Eveee/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-annotations/2.7.0/19f42c154ffc689f40a77613bc32caeb17d744e3/jackson-annotations-2.7.0.jar File3: /Users/Eveee/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.7.2/84ffa765dd258dbab8695963c41308b054f3a1cb/jackson-databind-2.7.2.jar ​​在module的gradle文件中添加如下代码即可: Android{ packagingOptions { exclude &apos;META-INF/DEPENDENCIES&apos; exclude &apos;META-INF/NOTICE&apos; exclude &apos;META-INF/LICENSE&apos; exclude &apos;META-INF/LICENSE.txt&apos; exclude &apos;META-INF/NOTICE.txt&apos; } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android LeakCanary学习笔记]]></title>
    <url>%2F2017%2F03%2F13%2FAndroid-LeakCanary%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Andriod</tag>
        <tag>内存优化</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio快捷键]]></title>
    <url>%2F2017%2F03%2F11%2FAndroid-Studio%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[一般IDE通过option + 方向键对光标进行单词的跳动，java中使用驼峰命名法较多，可以通过勾选 Editor - General - Smart Keys - 勾选Use “CamelHumps” words设置按单词跳动 由于设置了第一条进行单词跳动，双击鼠标的时候我们会发现选中的也只是驼峰命名法单词的其中的一个，所以我们需要取消勾选设置 Editor - General - Honor “CamelHumps” words settings when selecting on double click Command + shift + e 打开最近编辑的文件，配合Control + tab 键切换文件 Command + e 打开最近文件 Command + o 查找类文件，按两次可以选择 include non-projcet classes Command + shift + o 查找文件，按两次同样可以选择项目外的文件 Shift 点击两次，搜索所有地方,再点击两次可以同上 Command + [ – 后退 Command + ] – 前进 Command + shift + 方向键 移动行 option + F7 检查方法是在哪里被引用 Command + B类似于Command + 点击跳转到方法内部，如果是一个方法则检查引用 Command + P获取方法的参数，F1可以选择查看文档 Command + D复制行 alt + 鼠标 多行选择编辑，超极酷炫的小功能，别的文档编辑工具也支持 alt + shift + 鼠标可以创建一个光标，这样子就可以跨行选择了 command + shift + enter行尾补全 方法体大括号的添加 行尾分号的添加 自动格式化改行操作等 option + enter 快速生成变量 Command + +/- 展开/折叠代码 Command + Y 预览代码 Command + shift + v 查看最近复制的内容 Command + F12 预览一个类的结构 Control + T 快速重构 Command + J 缩写 Command + 方向键直接跳转到行首或者行尾 Shift + f6 重命名 Command + 1 显示隐藏Project窗口 Command + 6 显示隐藏Android Monitor窗口 Command + 9 显示隐藏Version Control窗口 Command + shift + f12 隐藏所有窗口]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-中获取文件的md5值]]></title>
    <url>%2F2017%2F03%2F11%2FAndroid-%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84md5%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在Android中获取文件的MD5值，来自CM /* * Copyright (C) 2012 The CyanogenMod Project * * * Licensed under the GNU GPLv2 license * * The text of the license can be found in the LICENSE file * or at https://www.gnu.org/licenses/gpl-2.0.txt */ package com.cyanogenmod.updater.utils; import android.text.TextUtils; import android.util.Log; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.math.BigInteger; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MD5 { private static final String TAG = &quot;MD5&quot;; public static boolean checkMD5(String md5, File updateFile) { if (TextUtils.isEmpty(md5) || updateFile == null) { Log.e(TAG, &quot;MD5 string empty or updateFile null&quot;); return false; } String calculatedDigest = calculateMD5(updateFile); if (calculatedDigest == null) { Log.e(TAG, &quot;calculatedDigest null&quot;); return false; } Log.v(TAG, &quot;Calculated digest: &quot; + calculatedDigest); Log.v(TAG, &quot;Provided digest: &quot; + md5); return calculatedDigest.equalsIgnoreCase(md5); } public static String calculateMD5(File updateFile) { MessageDigest digest; try { digest = MessageDigest.getInstance(&quot;MD5&quot;); } catch (NoSuchAlgorithmException e) { Log.e(TAG, &quot;Exception while getting digest&quot;, e); return null; } InputStream is; try { is = new FileInputStream(updateFile); } catch (FileNotFoundException e) { Log.e(TAG, &quot;Exception while getting FileInputStream&quot;, e); return null; } byte[] buffer = new byte[8192]; int read; try { while ((read = is.read(buffer)) &gt; 0) { digest.update(buffer, 0, read); } byte[] md5sum = digest.digest(); BigInteger bigInt = new BigInteger(1, md5sum); String output = bigInt.toString(16); // Fill to 32 chars output = String.format(&quot;%32s&quot;, output).replace(&apos; &apos;, &apos;0&apos;); return output; } catch (IOException e) { throw new RuntimeException(&quot;Unable to process file for MD5&quot;, e); } finally { try { is.close(); } catch (IOException e) { Log.e(TAG, &quot;Exception on closing MD5 input stream&quot;, e); } } } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uuid通用唯一识别码]]></title>
    <url>%2F2017%2F03%2F03%2Fuuid%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81%2F</url>
    <content type="text"><![CDATA[通用唯一识别码（Universal Unique Identifier简称UUID）是一种软件建构的标准。 UUID的目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来辨识信息的指定。如此依赖，每个人都可以穿件捕鱼其他人冲突的UUID。这样的情况下，就不需要考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软的全局统一标识符（GUID）。 定义UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为1632=2128，约等于3.4 x 1038。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。 UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符。示例： 550e8400-e29b-41d4-a716-446655440000 UUID亦可刻意重复以表示同类。例如说微软的COM中，所有组件皆必须实现出IUnknown接口，方法是产生一个代表IUnknown的UUID。无论是程序试图访问组件中的IUnknown接口，或是实现IUnknown接口的组件，只要IUnknown一被使用，皆会被参考至同一个ID：00000000-0000-0000-C000-000000000046。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-序列化]]></title>
    <url>%2F2017%2F02%2F26%2FAndroid-%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在Android中我们经常使用到序列化来进行数据传递,比如Intent和Binder,或者将对象持久化到存储设备或者通过网络传输到其他设备的时候.通常我们会有两种方式来实现序列化: 1.Serializable 2.Parcelable 1. Serializable方式实现序列化Serializable是java中所提供的一个序列化接口，它是空接口。通常我们可以通过实现Serializable接口来实现序列化，为对象提供标准的序列化和反序列化操作。同时我们注意到在实现该接口的时候我们会有一个long型的serialVersionUID，这个serialVersionUID主要是用于反序列化。如下所示： public class User implements Serializable { private static final long serialVersionUID = 7990301608074625143L; public static int GENDAT_FEMALE = 0; public static int GENDAT_MALE = 1; private String name; private int age; private int gendar; transient //序列化的时候忽略该字段 private int test; } 以上面的User类为例，将其一个对象写入文件以后再从文件读取：​ User user = new User(“Max”, 0, 0, 0); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(path)); outputStream.writeObject(user); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(path)); User reader = (User) inputStream.readObject(); Toast.makeText(this, reader.toString(), Toast.LENGTH_LONG).show(); ​当把对象user写入到文件中的时候，同时会写入对象的serialVersionUID，在从文件中读取对象的时候，]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-里面的几种倒计时方式]]></title>
    <url>%2F2017%2F02%2F24%2FAndroid-%E9%87%8C%E9%9D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E5%80%92%E8%AE%A1%E6%97%B6%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android常见的一些及时方式:TimeTask,CounterDownTimer,Handler.postDelay().a TimeTask ​ final Handler handler = new Handler() { ​ public void handleMessage(Message msg) { ​ switch (msg.what) { ​ case 1: ​ if (timerCount &gt; 0) { ​ btnGetVerifyCode.setEnabled(false); ​ btnGetVerifyCode.setText(&quot;重新获取(&quot; + String.valueOf(timerCount) + &quot;s)&quot;); ​ timerCount--; ​ } else { ​ btnGetVerifyCode.setEnabled(true); ​ btnGetVerifyCode.setText(&quot;重新获取&quot;); ​ if (task != null) { ​ task.cancel(); ​ } ​ } ​ break; ​ } ​ super.handleMessage(msg); ​ } }; class MyTimerTask extends TimerTask { @Override public void run() { Message message = new Message(); message.what = 1; handler.sendMessage(message); } } timerCount = 60; ​ task = new MyTimerTask();​ timer.schedule(task, 0, 1000); //延时1000ms后执行，1000ms执行一次​​ CountDownTimer new CountDownTimer(60000, 1000) { public void onTick(long millisUntilFinished) { mTextField.setText(&quot;seconds remaining: &quot; + millisUntilFinished / 1000); } public void onFinish() { mTextField.setText(&quot;done!&quot;); } }.start(); 不做详细说明了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-下面如何改变文件权限]]></title>
    <url>%2F2017%2F02%2F24%2FAndroid-%E4%B8%8B%E9%9D%A2%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[如何在Android系统下面改变我们的文件权限,实现某些目的: String command = &quot;chmod 777 &quot; + filePath; Runtime runtime = Runtime.getRuntime(); runtime.exec(command); 如上所示,获取文件的绝对路劲,通过Runtime去执行该文件,777代表可读可写可执行,这里不做更多说明.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-判断Library处于release或者debug模式]]></title>
    <url>%2F2017%2F02%2F21%2FAndroid-%E5%88%A4%E6%96%ADLibrary%E5%A4%84%E4%BA%8Erelease%E6%88%96%E8%80%85debug%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[如何在Library中判断是否是release包: 在Library的gradle文件中添加一个变量标记和设置没有默认发布类型 Android{ release { buildConfigField &quot;boolean&quot;, &quot;RELEASE_MODE&quot;, &quot;true&quot; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } debug { buildConfigField &quot;boolean&quot;, &quot;RELEASE_MODE&quot;, &quot;false&quot; } publishNonDefault true //设置没有默认发布类型 } 在app module的gradle文件中新增对应Library的release依赖和debug依赖 releaseCompile project(path: &apos;:app&apos;, configuration: &apos;release&apos;) debugCompile project(path: &apos;:app&apos;, configuration: &apos;debug&apos;) 在Library中引用 if (BuildConfig.RELEASE_MODE == true) {}]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-BaseColumns]]></title>
    <url>%2F2017%2F02%2F14%2FAndroid-BaseColumns%2F</url>
    <content type="text"><![CDATA[准备开始看Google官方的Android Architecture系列了，一方面是提升代码质量，另一方面是学习一下新的app架构。由于目前项目的代码基本上技术可以归属到上古遗迹之中，所以很有必要学习一下新的东西为未来做准备。 首先看到的就是在数据库操作方面的一个接口，如下所示： package android.provider; public interface BaseColumns { /** * The unique ID for a row. * &lt;P&gt;Type: INTEGER (long)&lt;/P&gt; */ public static final String _ID = &quot;_id&quot;; /** * The count of rows in a directory. * &lt;P&gt;Type: INTEGER&lt;/P&gt; */ public static final String _COUNT = &quot;_count&quot;; } 这个类主要是配合SQLiteOpenHelper进行Android的数据库管理，_ID做为主键，而_COUNT可以返回数据库行数。典型应用如下所示： public final class TasksPersistenceContract { // To prevent someone from accidentally instantiating the contract class, // give it an empty constructor. private TasksPersistenceContract() {} /* Inner class that defines the table contents */ public static abstract class TaskEntry implements BaseColumns { public static final String TABLE_NAME = &quot;task&quot;; public static final String COLUMN_NAME_ENTRY_ID = &quot;entryid&quot;; public static final String COLUMN_NAME_TITLE = &quot;title&quot;; public static final String COLUMN_NAME_DESCRIPTION = &quot;description&quot;; public static final String COLUMN_NAME_COMPLETED = &quot;completed&quot;; } } //在SQLiteOpenHelper中创建表的语句 private static final String SQL_CREATE_ENTRIES = &quot;CREATE TABLE &quot; + TasksPersistenceContract.TaskEntry.TABLE_NAME + &quot; (&quot; + TasksPersistenceContract.TaskEntry._ID + TEXT_TYPE + &quot; PRIMARY KEY,&quot; + TasksPersistenceContract.TaskEntry.COLUMN_NAME_ENTRY_ID + TEXT_TYPE + COMMA_SEP + TasksPersistenceContract.TaskEntry.COLUMN_NAME_TITLE + TEXT_TYPE + COMMA_SEP + TasksPersistenceContract.TaskEntry.COLUMN_NAME_DESCRIPTION + TEXT_TYPE + COMMA_SEP + TasksPersistenceContract.TaskEntry.COLUMN_NAME_COMPLETED + BOOLEAN_TYPE + &quot; )&quot;;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Comparator与Comparable的区别]]></title>
    <url>%2F2017%2F02%2F13%2FAndroid-Comparator%E4%B8%8EComparable%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[参考StackOverFlowp答案: Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android-Java时间比较]]></title>
    <url>%2F2017%2F02%2F13%2FAndroid-Java%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[在java中比较两个时间的大小: DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date start = df.parse(&quot;1991-12-25&quot;); Date end = df.parse(&quot;1990-12-23&quot;); int result = start.compareTo(end); 如果result &gt; 0 说明 start &gt; end; 如果result &lt; 0，则 start &lt; end;如果result = 0,则 start = end;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网协议入门（二）]]></title>
    <url>%2F2017%2F02%2F06%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇文章分析了互联网的总体构思，从下至上，没一层协议的设计思想。 这是从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。 互联网协议入门（二）七、一个小结先对前面的内容，做一个小结。 我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后则会收到了，回复一个数据包，从而实现两台电脑时间的通信，数据包的结构，基本上是下面这样： 发送这个包，需要知道两个地址： 对方的MAC地址 对方的IP地址 有了折两个地址，数据包才能准确送到接收者中。但是，前面说过，MAC地址又局限性，如果两台电脑不在同一个局域网，就无法知道对方的MAC地址，必须通过网关转发。 上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，借过发现不是（后文会介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于局域网B，又把数据包发送给网关B，网关B再转发到4号电脑。 1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况： 场景 数据包地址 同一个局域网 对方的MAC地址，对方的IP地址 不同局域网 网关的MAC地址，对方的IP地址 发送数据包之前，电脑必须判断对方是否在同一个局域网，然后选择对应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。 八、用户的上网设置8.1 静态IP地址通常购买了一台电脑后需要做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们呢填入操作系统，计算机就能上网了。 本机的IP地址 子网掩码 网关的IP地址 DNS的IP地址 下图是Windows系统的设置窗口。 这四个参数缺一不可，后文会解释为什么需要知道它们才能上网，由于它们是给定的，计算机每次开机，都回分到同样的IP地址，所以这种状况称作“静态IP地址上网”。 8.2 动态IP地址所谓“动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不同认为设定。它使用的协议叫做DHCP协议 这个协议规定，每一个局域网中，有一台计算机负责管理本网络的所有IP地址，它叫做“DHCP服务器”。新的计算机加入网络，必须向“DHCP服务器”发送一个“DHCP请求”数据包，申请IP地址和相关的网络参数。 前面说过，如果两台计算机在同一个局域网，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？ DHCP协议做了一些巧妙的规定。 8.3 DHCP协议首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的L 最前面的“以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF. 后面的“IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方地址设置为255.255.255.255。 最后的“UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。 这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个局域网的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，每台接收到这个包的计算机，都必须解析这个包的IP地址，才能确定是不是发给自己的。当看到发送方是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器就知道“这个包是发给我的”，而其他计算机就可以丢弃这个包。 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送会去一个“DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出放）和255.255.255.255（接收方），UDP标头的端口是67（发出放）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在“数据”部分。 新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。 8.4 上网设置：小结这个部分，需要记住的就是一点：不管是“静态IP地址”还是“动态IP地址”，电脑上网的首要步奏，是确定四个参数。这四个参数很重要，值得重复一遍： 本机的IP地址 子网掩码 网关的IP地址 DNS的IP地址 有了这几个数值，电脑就可以上网“冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。 九、一个实例：访问网页9.1 本机参数我们假定，经过上一节的步奏，用户设置好了自己的网络参数： 本机的IP地址：192.168.1.100 子网掩码：255.255.255.0 网关的IP地址：192.168.1.1 DNS的IP地址：8.8.8.8 然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。 http://image.beekka.com/blog/201206/bg2012061103.png 9.2 DNS协议我们知道，发送数据包，必须知道对方的IP地址。但是，现在，我们知道的网址是www.google.com，不知道它的IP地址。 DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。 然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。 9.3 子网掩码接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。 已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。 因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。 9.4 应用层协议浏览网页用的是HTTP协议，它的整个数据包构造是这样的： HTTP部分的内容，类似于下面这样： GET / HTTP/1.1 Host: www.google.com Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 6.1) ...... Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3 Cookie: ... ... 我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。 9.5 TCP协议TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。 TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。 9.6 IP协议然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。 IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。 9.7 以太网协议最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。 以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。 9.8 服务器端响应经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。 根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。 本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。 这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网协议入门（一）]]></title>
    <url>%2F2017%2F02%2F05%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文转载自阮一峰的网络日志互联网协议入门. 互联网的核心是一系列的协议,总称为”互联网协议”(Internet Protocol Suite)。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。 互联网入门一、概述1.1 五层模型互联网的实现，分为很多层次。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。 正常来说，用户接触到的，是最上面的一层，而无法感知到下面的层。要理解互联网，就必须从最下层开始，自下而上理解每一层的功能。 互联网的分层有不同的模型，有OSI七层模型,有的分四层TCP/IP协议簇，按照作者的理解将互联网分为五层。 如上图所示，最底下的一层叫做”实体层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。 1.2 层与协议每一层都是为了完成一种功能。为了实现这些功能，就需要大家遵守共同的规则。 大家都遵守的规则，就叫做”协议”（Protocol）。 互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要是介绍每一层的主要协议。 二、实体层从最下层的实体层开始。 电脑要组网，第一件事要干什么？当然是要把电脑连接起来，可以使用光缆、电缆，双绞线，无线网络等等方式。 这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号（电磁波）。 三、链接层3.1 定义单纯的0和1是没有任何意义的，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？ 这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式 3.2 以太网协议早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网“（Ethernet）的协议，占据了主导地位。 以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data） “标头”包好数据包的一些说明项，比如发送者，接收者，数据类型等等；”数据”则是数据包的具体内容。 “标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。 3.3 MAC地址上面提到，以太网数据包的”标头”，包含了发送者和接收者的信息。那么，发送者和接收者是如何标识呢？ 以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址(Media Access Control Address)。 每块网卡出厂的时候，都有一个全世界独一无二的MAC地址 ，长度是48个二进制位，通常用12个十六进制数表示。 前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。根据Wiki:(MAC地址共48位（6个字节），以十六进制表示。前24位由IEEE决定如何分配，后24位由实际生产该网络设备的厂商自行指定。) 3.4 广播定义地址只是第一步，后面还有更多的步奏。 首先，一块网卡怎么会知道另一块网卡的MAC地址？ 答案就是ARP协议，后面将会介绍。以太网数据包必须知道接收方的MAC地址，然后才能发送。 其次，就算有了MAC地址，系统怎样才能吧数据包准确的送到接收方？ 答案是以太网采用了一种”原始”的方式，它不是把数据包准确送到接收方，而是向局域网内所有计算机发送，让每台计算机自己判断，是否为接收方。 上图中，1号计算机向2号计算机发送一个数据包，同一个局域网的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址进行比较，如果两者相同，则接收这个包，做进一步处理，否则就丢弃这个包。这种发送方式叫做”广播”。 有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。 四、网络层4.1 网络层的由来以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。 但是，这样做有一个重大的缺点。以太网采用广播的形式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的网络。也就是说，不同局域网之间，广播是无法送达的。这种设计是合理的，否则互联网上的每一台计算机都会收到所有包，那会引起灾难。 互联网是无数局域网共同组成的一个巨型网络，很难想象上海和洛杉矶的电脑会在同一个局域网，这几乎是不可能的。 因此，必须找到一种方法，能够区分哪些MAC地址属于同一个局域网，哪些不是。如果是同一个子网络，就采用广播的形式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。 这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否是属于同一个子网络。这套地址叫做”网络地址”，简称”地址”。 于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，一种是网络地址。两种地址之间没有任何联系的，MAC地址是绑定在网卡上的，网络地址则是管理员分配的。 网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络的目标网卡。因此，从逻辑上可以判断，必定是先处理网络地址，然后再处理MAC地址。 4.2 IP协议规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。 目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。 习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。 互联网上的每一条计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位，那么主机部分就是后8位。处于同一个子网络的电脑，它们IP地址的网络部分必须是相同的。 但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。 那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。 所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。 总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 4.3 IP数据包根据IP协议发送的数据，叫做IP数据包。不难想象，其中必定包括IP地址信息。 但是前面阿说过，以太网数据包只包含MAC地址，并没有IP地质的栏位。那么是否需要修改数据定义，再添加一个栏位呢？ 答案是不需要，我们可以把IP数据包直接放到以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及到下层的结构。 具体来说，IP数据包也分为”标头”和”数据”两个部分。 “标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变为了下面这样。 IP数据包的”标头”部分的长度为20到60个字节，整个数据包的最大长度为65535字节。因此，理论上一个IP数据包的”数据”部分，最长为65515字节。前面有提到，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成多个以太网数据包，分开发送了。 4.4 ARP协议关于”网络层”，还有一点需要说明。 因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的，但是我们不知道它的MAC地址。 所以，我们需要一种机制，能够从IP地址取到MAC地址。 这里又分为两种状况。第一种状况，如果两台主机不再同一个子网络，那么事实上没有办法去的对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”，让网关去处理。（当发送主机和目的主机不在同一个局域网中时，即便知道目的主机的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。） 第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议地址解析协议Address Resolution Protocol（注意：在IPv6中已经被邻居发现协议（Neighbor Discovery Protocol）），去的对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询诸暨的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议以后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 五、传输层5.1 传输层的由来有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上简历通信。 接下来的问题是，同一台主机上又许多程序都需要用到网络。比如，你一边浏览网页，一边与朋友在线聊天，当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”，它其实是没一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能读取到自己所需要的数据。 “端口”是0到65535之间的一个整数，正好是16个二进制位。0到1023的端口被系统占用，用户只能选择大于1023的端口，不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口通信。 “传输层”的功能，就是简历“端口到端口”的通信。只有确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做“套接字”（Socket）。有了它，就可以进行网络应用程序的开发了。 5.2 UDP协议现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。 UDP数据包，也是由“标头”和“数据”两部分组成。 “标头”部分主要是定义了发出端口和接收端口，“数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的“数据”部分，而前面说过，IP数据包又是放在以太网数据包中，所以整个以太网数据包就变成了下面这样： UDP数据包非常简单，“标头”部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据包。 5.3 TCP协议UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。 为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似人为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失。就收不到确认，发出放就知道有必要重发这个数据包了。 因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。 TCP数据包和UDP数据包一样，都是内嵌在IP数据包的“数据”部分。TCP数据包没有长度限制，理论上可以无现场，但是为了保证网络效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 六、应用层应用程序收到“传输层”的数据，接下来就要进行解毒。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。 “应用层”的作用，就是规定应用程序的数据格式 举例来说，TCP协议可以为各种各样的陈旭传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了“应用层”。 这是最高的一层，直接面对用户。它的数据就放在TCP数据包的“数据”部分。因此，现在的以太网的数据包就变成下面这样。 至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。下一篇，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言中的fmt包学习]]></title>
    <url>%2F2017%2F01%2F29%2Fgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84fmt%E5%8C%85%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[go doc fmt list all the data belowprintThe verbs: General: %v the value in a default format when printing structs, the plus flag (%+v) adds field names %#v a Go-syntax representation of the value %T a Go-syntax representation of the type of the value %% a literal percent sign; consumes no value Boolean: %t the word true or false Integer: %b base 2 %c the character represented by the corresponding Unicode code point %d base 10 %o base 8 %q a single-quoted character literal safely escaped with Go syntax. %x base 16, with lower-case letters for a-f %X base 16, with upper-case letters for A-F %U Unicode format: U+1234; same as &quot;U+%04X&quot; Floating-point and complex constituents: %b decimalless scientific notation with exponent a power of two, in the manner of strconv.FormatFloat with the &apos;b&apos; format, e.g. -123456p-78 %e scientific notation, e.g. -1.234456e+78 %E scientific notation, e.g. -1.234456E+78 %f decimal point but no exponent, e.g. 123.456 %F synonym for %f %g %e for large exponents, %f otherwise %G %E for large exponents, %F otherwise String and slice of bytes (treated equivalently with these verbs): %s the uninterpreted bytes of the string or slice %q a double-quoted string safely escaped with Go syntax %x base 16, lower-case, two characters per byte %X base 16, upper-case, two characters per byte Pointer: %p base 16 notation, with leading 0x There is no ‘u’ flag. Integers are printed unsigned if they have unsignedtype. Similarly, there is no need to specify the size of the operand (int8,int64). The default format for %v is: bool: %t int, int8 etc.: %d uint, uint8 etc.: %d, %x if printed with %#v float32, complex64, etc: %g string: %s chan: %p pointer: %p Control width and precision: %f default width, default precision %9f width 9, default precision %.2f default width, precision 2 %9.2f width 9, precision 2 %9.f width 9, precision 0 一些小区别函数 fmt.Sprintf 与 Printf 的作⽤是完全相同的，不过前者将格式化后的字符串以返 回值的形式返回给调⽤者，因此你可以在程序中使⽤包含变量的字符串]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言中的init()函数]]></title>
    <url>%2F2017%2F01%2F29%2Fgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84init-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在go语言中,有一类比较特殊的函数,不能够被人为的调用,而是在每个包完成初始化动作后自动执行,而且执行优先级比main函数高. 没一个源文件都可以包含一个或者多个init函数.初始化工作是以单线程执行,并且按照包的依赖关系顺序执行.一个可能的用途是在开始执行程序之前对数据进行检验或者修复,以保证程序状态的正确性.]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年度flag]]></title>
    <url>%2F2017%2F01%2F26%2F2017%E5%B9%B4%E5%BA%A6flag%2F</url>
    <content type="text"><![CDATA[private]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker学习,常用指令]]></title>
    <url>%2F2017%2F01%2F24%2FDocker%E5%AD%A6%E4%B9%A0-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[DockerDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离， 属于操作系统层面的虚拟化技术。 常用指令 docker run -p 2222:22 imagename //运行改image做为container,不存在则会从Docker hub获取并运行; -p 指定本地映射关系,前面是访问地址端口,后面是映射的容器端口 docker exec -it goofy_banach /bin/bash 对比于attach方式,会立即显示进入,并且退出不会导致容器关闭 docker ps //获取正在运行的镜像 -a 所有的镜像 touch Dockerfile //创建docker脚本 cat Dockerfile //查看脚本 docker build -t docker-whale . //创建镜像, -t打tag,后面的.(表示当前目录)不能少 docker tag 7d9495d03763 maryatdocker/docker-whale:latest 标记docker镜像 docker login 登录 docker push maryatdocker/docker-whale 上传到docker hub docker rmi -f 7d9495d03763/imagename 移除镜像 docker run yourusername/docker-whale docker images 查看所有镜像 docker rmi $(docker images -q -f dangling=true) 删除无用的悬浮镜像 docker exec -it webserver bash 运行命令行并启动 docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 提交更新,创建镜像谨慎使用,因为会对容器环境照成较大影响 //docker commit –author “Tao Wang &#x74;&#119;&#x61;&#110;&#103;&#50;&#50;&#x31;&#x38;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;“ –message “修改了默认网页” webserver nginx:v2 docer diff NAMES 查看永久性更新 docker history nginx:v2 查看历史更新 docker rm 删除容器 docker run -it -–entrypoint /bin/bash karalabe/xgo-latest 强制使用bash启动docker镜像 docker run -it -v /Volumes/Work/go/src/golang.org:/src golang/mobile /bin/bash 挂载宿主机目录到容器 sudo yum upgrade docker 更新docker docker cp 2e8a06b7cff6:/gopath/src/golang.org/x/mobile/example/GoHello/app/src Storage-2e8a06b7cff6/ docker logs id/names 查看操作日志 docker top 显示容器进程 docker stats 查看容器进程状态 ####tag本地镜像并提交到docker仓库step1——找到本地镜像的ID：docker images step2——登陆Hub：docker login –username=username –password=password –email=email step3——tag：docker tag /: step4——push镜像：docker push / Dockerfile创建 mkdir test cd test touch Dockerfile 基本用法 FROM nginx 指定基础镜像,这个是必须的(可以指定一个空白镜像名为scratch) RUN 没一个RUN代表一层,因此同一个目的的RUN通过&amp;&amp;合并命令,浓缩到一层 (层数限制旧版42,新版127) COPY package.json /usr/src/app/ || hom?.txt /mydir/ ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz / src可以是url,加强版的COPY,还可移植性解压缩 docker build -t docker-whale . docker build [选项] &lt;上下文路径/URL/-&gt; .代表当前目录 -t代表tag ENTRYPOINT 只有最后一个生效 run的时候通过–entrypoint使其生效 Docker基本概念Docker包括三个基本概念,包含了Docker的整个生命周期 镜像(Image) 容器(Container) 仓库(Repository) Docker镜像Docker镜像,相当于一个root文件系统(操作系统分为内核和用户空间,内核启动后,会挂载root文件系统为用户空间提供支持),镜像不包含任何动态数据.提供容器运行时所需的程序、库、资 源、配置等文件外,还包含了一些为运行时准备的一些配置参数（如匿名卷、环境 变量、用户等）. 分层存储镜像包含操作系统完整的root文件系统,体积较大,Docker设计时,采用了Union FS技术,分层存储的架构. 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生 改变，后一层上的任何改变只发生在自己这一层,任何额外的东西应该在该层构建结束前清理掉。 Docker容器类比于面向对象程序设计中 的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017阅读记录]]></title>
    <url>%2F2017%2F01%2F24%2F2017%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[一些好的技术文章]]></title>
    <url>%2F2017%2F01%2F22%2F%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[本文旨在收集一些个人比较感兴趣的技术类的文章,希望更多的成长学习. Linux类 Linux系统中“动态库”和“静态库”那点事儿. 静态库与动态库的使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux系统中动态库和静态库]]></title>
    <url>%2F2017%2F01%2F22%2FLinux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[原文转载自wjlkoorey的博客最近一直在学习go语言跨平台编译,在这个过程中也学习了其它很多的内容,今天回顾一下Linux系统下动态库(.so)和静态(.a)的程序那些猫腻.在这之前，我们需要了解一下源代码到可执行程序之间到底发生了什么神奇而美妙的事情。 在Linux操作系统中，普遍使用ELF格式作为可执行程序或者程序生成过程中的中间格式。ELF（Executable and Linking Format，可执行连接格式）是UNIX系统实验室（USL）作为应用程序二进制接口（Application BinaryInterface，ABI）而开发和发布的。工具接口标准委员会（TIS）选择了正在发展中的ELF标准作为工作在32位Intel体系上不同操作系统之间可移植的二进制文件格式。源代码到可执行程序的转换时需要经历如下图所示的过程： 编译是把高级语言编写的程序转换为对应处理器的汇编语言的过程.从本质上来说,编译是一个文本转换的过程.对嵌入式系统而言,一般要把用C语言编写的程序转换成处理器的会变代码.编译过程包含了C语言的语法解析和汇编代码的生成两个步骤.编译一般是逐个文件进行的,对于一个C语言编写的文件,可能还需要进行预处理. 汇编是从会变语言程序生成目标系统的二进制代码(机器码)的过程,机器码的生成和处理器有密切的关系.相对于编译过程的语法解析,汇编的过程相对简单.这是因为对于一款特定的处理器,其汇编语言和二进制的机器代码是一一对应的.汇编过程的输入是汇编代码,这个汇编代码可能来源于编译过程的输出,也可以是直接使用汇编语言书写的程序. 连接是指将汇编生成的多段机器代码组合成一个可执行程序.一般来说,通过汇编和汇编过程,每个源文件将生成一个目标文件.连接器的作用是将这些目标文件组合起来,组合的过程包括了代码段,数据段等部分的合并,以及添加相应的头文件 GCC是Linux下主要的程序生成工具,它除了汇编器,编译器,连接器外,还包括一些辅助工具.在下面的分析过程中我会教大家这些工具的基本使用方法. 作为UNIX操作系统的一种，Linux的操作系统提供了一系列的接口，这些接口被称为系统调用（System Call）。在UNIX的理念中，系统调用“提供的是机制，而不是策略“。C语言的库函数通过调用系统调用来实现，库函数对上层提供了C语言库文件的接口。在应用程序层，通过调用C语言库函数和系统调用来实现功能。一般来说，应用程序大多使用C语言库函数实现其功能，较少使用系统调用。 那么最后的可执行文件到底是什么样子呢？前面已经说过，这里我们不深入分析ELF文件的格式，只是给出它的一个结构图和一些简单的说明，以方便大家理解。 ELF文件格式包括三种主要的类型：可执行文件、可重定向文件、共享库。 1.可执行文件可执行文件包含了代码和数据，是可以直接运行的程序。 2.可重定向文件可重定向文件又称为目标文件，它包含了代码和数据（这些数据是和其他重定位文件和共享的object文件一起连接时使用的）。 *.o文件参与程序的连接（创建一个程序）和程序的执行（运行一个程序），它提供了一个方便有效的方法来用并行的视角看待文件的内容，这些*.o文件的活动可以反映出不同的需要。 Linux下，我们可以用gcc -c编译源文件时可将其编译成*.o格式。 3.共享库也称为动态库文件，它包含了代码和数据（这些数据是在连接时候被连接器ld和运行时动态连接器使用的）。动态连接器可能称为ld.so.1，libc.so.1或者 ld-linux.so.1。 一个ELF文件从连接器（Linker）的角度看，是一些节的集合；从程序加载器（Loader）的角度看，它是一些段（Segments）的集合。ELF格式的程序和共享库具有相同的结构，只是段的集合和节的集合上有些不同。 那么到底什么是库呢？库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。 静态库：这类库的名字一般是libxxx.a，xxx为库的名字。利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中，他的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。 动态库：这类库的名字一般是libxxx.M.N.so，同样的xxx为库的名字，M是库的主版本号，N是库的副版本号。当然也可以不要版本号，但名字必须有。相对于静态函数库，动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。linux系统有几个重要的目录存放相应的函数库，如/lib /usr/lib。 当要使用静态的程序库时，连接器会找出程序所需的函数，然后将它们拷贝到执行文件，由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。然而，对动态库而言，就不是这样。动态库会在执行程序内留下一个标记指明当程序执行时，首先必须载入这个库。由于动态库节省空间，linux下进行连接的缺省操作是首先连接动态库，也就是说，如果同时存在静态和动态库，不特别指定的话，将与动态库相连接。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>动态库</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-数据持久化]]></title>
    <url>%2F2017%2F01%2F19%2FAndroid-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[今天晚上Android项目组的小伙伴一起聊了一下Android数据持久化的几种方式外加一些项目中的总结吧.突然发现一些不怎么用的东西都已经快忘光了,比如说ContentProvider + LoadManger + URIMatcher + CursorAdapter,今天突然提到LoadManager感觉像是一个没接触过的东西,被小伙伴提了一下才记得有这个类的存在,更别提ContentObserver了.有点跑题了还是聊一下Android的数据持久化策略吧! ##Android数据持久化的方式总所周知,Android共有五种数据持久化的方式,这里是官方文档.通过阅读API Guidance可知,这其中方式分别如下: ###1. SharePreference通常用于存储一些本地化的配置文件,主要分为读和取,操作如下: 1.写入操作​ // We need an Editor object to make preference changes. // All objects are from android.context.Context​ SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);​ SharedPreferences.Editor editor = settings.edit();​ editor.putBoolean(“silentMode”, mSilentMode);​ // Commit the edits!​ editor.commit();​ //finally we can see these file in data/data/packagename/shared_preference if your device has been rooted;2.读取操作​ // Restore preferences SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0); //false stands for the default value, you can customize yourself boolean silent = settings.getBoolean(“silentMode”, false); ###2. Internal Storage第一点提到的SharePreference存储的方式最终存放的位置就是在Internal Storage中 String FILENAME = &quot;hello_file&quot;; String string = &quot;hello world!&quot;; //finally the file path is data/data/packagename/files/hello_file //and there are kinds of MODE(MODE_PRIVATE,MODE_APPEND,MODE_WORLD_READABLE,MODE_WORLD_WRITABLE) FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE); fos.write(string.getBytes()); fos.close(); ​值得注意的是从API 17开MODE_WORLD_READABLE跟MODE_WORLD_WRITABLE已经是deprecated的状态.从API 23开始,由于谷歌收紧了Android系统的权限(Android越来越封闭,苹果越来越开放,目的都是为了体验越来越好!),如果还使用这两个属性会直接抛出异常SecurityException.因此如果你的应用的TargetVersion在API 23,那么如果你想共享应用的内部数据则只能通过主动分享的方式发起共享,详见参考文档. 正如官方文档所提,如果想要存储静态文件,比如说应用的铃声之类的文件,可以放在项目的res/raw/路径下,通过openRawResource(R.raw.fileId)获取对应的资源文件. ####保存Cache文件通过getCacheDir()可以返回app内部的cache文件,该目录即data/data/packagename/cache由系统维护,但是谷歌的官方建议是自行维护1MB左右,该目录会随着应用卸载而被清理掉.其他诸如getFileDir(),getDir()会在后文有个总结性的说明. ###3. External StorageAndroid的外部存储可以分为可卸载的存储例如SD卡,以及不可卸载的内部存储(Internal Storage).通过USB文件传输模式连接的时候,用户可以对外部存储进行操作. 当用户挂载外部存储或者移除外部存储的时候,应用就无法操作外部存储了.同时外部存储的全局可读特性也决定了它本身并没有安全性可言. ####获取访问外部存储的权限如果你的应用需要读写外部存储则需要在manifest文件中配置如下权限:​ … 如果只需要读取权限只需申明READ_EXTERNAL_STORAGE权限即可;如果需要读写权限只需要申明WRITE_EXTERNAL_STORAGE权限即可,因为系统会同时声明读取权限. 注意:从Android4.4开始,如果只需要读写app内部的文件,则无需申明读写权限. ####检查是否具备读写权限无论在什么地方进行外部存储操作的时候你都应该检查外部存储是否处于可用状态. /*Ckecks if external storage is available for read and write\*/ public boolean isExternalStorageAvailable(){ String state = Environment.getExternalStorageState(); return Environment.MEDIA_MOUNTED.equals(); } 通过Environment.getExternalStorageState()可以获得外部存储的状态,如连接到电脑,彻底移除,不恰当的移除等等;此时你可以通过判断外部存储的状态来决定是否需要访问外部存储的媒体文件.如下所示为外置存储的不同状态: public static final String MEDIA_BAD_REMOVAL = &quot;bad_removal&quot;; public static final String MEDIA_CHECKING = &quot;checking&quot;; public static final String MEDIA_EJECTING = &quot;ejecting&quot;; public static final String MEDIA_MOUNTED = &quot;mounted&quot;; public static final String MEDIA_MOUNTED_READ_ONLY = &quot;mounted_ro&quot;; public static final String MEDIA_NOFS = &quot;nofs&quot;; public static final String MEDIA_REMOVED = &quot;removed&quot;; public static final String MEDIA_SHARED = &quot;shared&quot;; public static final String MEDIA_UNKNOWN = &quot;unknown&quot;; public static final String MEDIA_UNMOUNTABLE = &quot;unmountable&quot;; public static final String MEDIA_UNMOUNTED = &quot;unmounted&quot;; ####保存文件共享给其他应用主要是公共的多媒体库,例如MUSIC,PICTURE等等,通过以下方式获得 Environment.getExternalPublicDirectory(String type) 其中type可分为如下几种,对应到外部存储的不同位置. public static String DIRECTORY_ALARMS; public static String DIRECTORY_DCIM; public static String DIRECTORY_DOCUMENTS; public static String DIRECTORY_DOWNLOADS; public static String DIRECTORY_MOVIES; public static String DIRECTORY_MUSIC; public static String DIRECTORY_NOTIFICATIONS; public static String DIRECTORY_PICTURES; public static String DIRECTORY_PODCASTS; public static String DIRECTORY_RINGTONES; ​ ####保存应用私有文件如果你的应用有一些私有文件,如音效文件,此时可以在外部存储中创建一个私有的文件目录:​ //if you pass null as the type return the root directory //storage/emulated/0/Android/data/packagename/ //of course you can pass non null type to create a subdirectory Context.getExternalFilesDir(String type) 从Android 4.4开始,读写应用的私有空间的文件并不需要读写权限,因此如果其他地方无需读写权限的情况下可以通过一下方式申明: &lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; android:maxSdkVersion=&quot;18&quot; /&gt; ... &lt;/manifest&gt; 这里有个事情需要说明的是,这个应用的私有目录会随着应用的卸载而删除.同时,在媒体库中并不会显示应用的私有文件,因此,如果在你的app中属于用户的文件是不能保存到这个目录的,例如用户购买的音乐. 有些手机会把内置存储划出来一部分做为外置存储使用(我们现在使用的多数都是这种方式),但是的手机还提供了SD卡卡槽.对于Android 4.3及以下的设备,通过getExternalFilesDir()只能获得内置存储中划出来的那一部分,也就是说并不能获得SD卡部分.从Android4.4开始通过getExternalFilesDir()返回的是一个数组.只有在内置存储划分的外置存储不可用或者占用满的情况下才选择使用SD卡做为应用的私有存储空间.如果想要在Android4.3及以下的设备中获取该路径则通过兼容包ContextCompact.getExternalFilesDirs()获取. 需要注意的是,尽管对于媒体中心(MediaStore)而言,应用外部存储的私有空间是不可见的,但是对于其他具有读取或者写入存储权限的软件而言,放在外部存储的文件是可读可写的.因此,如果你不想你的文件被别的软件使用或者更改的话,就只能放到应用的内部空间了. ####保存缓存文件通过如下方式获得缓存文件的保存目录,缓存目录会随着应用的卸载而被删除:​ getExternalCacheDir(); 跟上面提到的类似,你也可以通过ContextCompact.getExternalCacheDirs()获得SD卡之类的外置存储的缓存路径. 在代码开发的时候我们应该特别注意缓存文件的维护,防止缓存文件占用过多的空间.比如说我们使用一些第三方的框架的时候会让我们配置缓存空间大小. ##Using DatabasesAndroid支持SQLite的所有功能,在应用里面创建的数据库能够被应用的任何一个类访问,但是不能在应用外访问.通常可以配合URIMatcher + ContentProvider + SQLiteOpenHelper进行数据库数据共享,列入联系人的获取. ##Using NetWork Connection即数据存储在服务端,通过网络获取持久化数据. ##总结前面基本上是对于官方文档的一种翻译和理解,后面来说一下自己的总结,首先观察一下现象 ///storage/emulated/0/Android/data/com.max.testuninstall/cache Log.d(TAG, &quot;onCreate: 外部缓存存储&quot; + this.getExternalCacheDir().toString()); //storage/emulated/0/Android/data/com.max.testuninstall/files Log.d(TAG, &quot;onCreate: 外部私有存储&quot; + this.getExternalFilesDir(null).toString()); ///storage/emulated/0 Log.d(TAG, &quot;onCreate: 外部共用存储&quot; + Environment.getExternalStorageDirectory().toString()); ///data/user/0/com.max.testuninstall/cache Log.d(TAG, &quot;onCreate: 内部缓存存储&quot; + this.getCacheDir().toString()); ///data/user/0/com.max.testuninstall/files Log.d(TAG, &quot;onCreate: 内部文件存储&quot; + this.getFilesDir().toString()); ///data/user/0/com.max.testuninstall/app_null Log.d(TAG, &quot;onCreate: 内部文件存储&quot; + this.getDir(null, MODE_PRIVATE).toString()); ///data/user/0/com.max.testuninstall/app_hello_world Log.d(TAG, &quot;onCreate: 内部文件存储&quot; + this.getDir(&quot;hello_world&quot;, MODE_PRIVATE).toString()); ///data/user/0/com.max.testuninstall/files(List) Log.d(TAG, &quot;onCreate: 内部文件存储,返回目录下所有文件&quot; + this.fileList().toString()); String FILENAME = &quot;hello_file&quot;; String string = &quot;hello world!&quot;; //data/data/packagename/files/hello_file FileOutputStream fos = this.openFileOutput(FILENAME, Context.MODE_PRIVATE); fos.write(string.getBytes()); fos.close(); ​以上对应前文所说的通过不同方式获取内部,外部文件及缓存路径. ###读写权限Internal Storage本身无需声明任何权限即可进行读写操作.External Storage从Android4.4开始读写应用私有空间无需声明读写权限,Android4.3及以下需要声明读写权限.Android系统中写入External Storage权限包含读取External Storage权限. ###应用卸载通过上面对应的日志结合实际操作发现,Context获取的路径在应用卸载的时候会被同时删除,其实这也是可以理解的,毕竟是属于应用私有的文件.通过Environment获得的路径属于外界环境的,所以不会跟随应用的卸载而被删除掉. ###多用户在/storage/emulated/目录下面会有 0(默认用户),如果新建一个用户则是10,再新建则是11依此类推.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ADB命令大全]]></title>
    <url>%2F2017%2F01%2F19%2FAndroid-ADB%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[adb shell dumpsys package packagename //获取所有app的信息 adb shell ps | grep packagename //获取指定app的进程信息]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Android</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Root Nexus 6 Android 7.1 官方镜像]]></title>
    <url>%2F2017%2F01%2F19%2FRoot-Nexus-6-Android-7-1-%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[本教程适用于Android7.1官方系统的Nexus 6 Root, 使用于Android 7.1.1 N6F26Q Nougat,请确保你将要root的是该设备. 原文地址,可自行查看. 注意 本教程仅适用于安装 Android 7.1.1 (N6F26Q) 的Nexus 6设备,我自己的美版型号root正常. 手机需要解锁bootloader教程 系统必须为Android 7.1.1 N6F26Q Nougat官方镜像 教程 详细步骤 下载Android SDK工具地址,仅获取命令行工具即可.这个地址需要翻墙 打开开发者选项里面的USB调试 下载SuperSU 拷贝到手机存储空间根目录 下载TWRP 关机后按音量- 和 关机键进入bootloader模式,使用下载的命令行工具刷入twrp(如果没有添加命令行工具路径到环境变量则需要在放置命令行工具): fastboot flash recovery twrp-3.0.2-0-shamu.img 刷入完成后,选择RECOVERY模式进入 选择flash zip from SD card,选中前面的SuperSU XX文件,按电源键确认刷入 最后选择reboot system,重启以后如果有了SuperSU这个app说明root成功了.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Root</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务端更新Android SDK]]></title>
    <url>%2F2017%2F01%2F19%2FLinux%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9B%B4%E6%96%B0Android-SDK%2F</url>
    <content type="text"><![CDATA[更新内容 更新（2018-11-18，更新使用sdkmanager，更新jcenter和google的仓库） 使用android前段时间因为新版本需求更新了一下项目的Recycleview版本,对应的SDK也更新了.项目组的几位同事的项目全都因为找不到对应的SDK报错了,后面把自己的SDK拷贝一份给他们才OK(实在想吐槽一下,我觉得做为一个Android程序员翻墙是一项基本的技能).然而就在今天根据新的安排,后续打包统一走运维.而运维使用的是jenkins集成打包,然后上传到fir,测试人员直接下载安装然后进行测试.结果服务端果然出现了同样的错误. Could not resolve all dependencies for configuration &apos;:app:_debugCompile&apos;. &gt; Could not find com.android.support:recyclerview-v7:23.4.0. Searched in the following locations: https://jcenter.bintray.com/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom https://jcenter.bintray.com/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar file:/root/.jenkins/jobs_android/workspace/appbs/recyclerview-v7-23.4.0.jar file:/root/.jenkins/jobs_android/workspace/appbs/recyclerview-v7.jar file:/usr/local/android/extras/android/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom file:/usr/local/android/extras/android/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar file:/usr/local/android/extras/google/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom file:/usr/local/android/extras/google/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar Required by: workspace:app:unspecified workspace:app:unspecified &gt; com.yanzhenjie:recyclerview-swipe:1.0.1 &gt; Could not find com.android.support:recyclerview-v7:23.4.0. Searched in the following locations: https://jcenter.bintray.com/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom https://jcenter.bintray.com/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar file:/root/.jenkins/jobs_android/workspace/appbs/recyclerview-v7-23.4.0.jar file:/root/.jenkins/jobs_android/workspace/appbs/recyclerview-v7.jar file:/usr/local/android/extras/android/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom file:/usr/local/android/extras/android/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar file:/usr/local/android/extras/google/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.pom file:/usr/local/android/extras/google/m2repository/com/android/support/recyclerview-v7/23.4.0/recyclerview-v7-23.4.0.jar Required by: workspace:app:unspecified &gt; com.android.support:design:23.1.1 然后我就跟运维的胖哥搜索教程,第一步去Github上面下载了lantern (Lantern都有付费版本了),然后去谷歌搜索Linux update Android SDK,然后找到了官方的教程,在GFW的帮助下,并没有什么用. 第二步,想在运维那里直接使用云梯翻墙更新(这里吐槽一下,云梯实在很不稳定,建议自己买VPS+Shadowsocks才是王道).跟预料的一样,根本连不上. 第三步,其实一开始思路就是错的,用什么谷歌搜索,只有少数的被国家保护的公民才有这种问题啊,所以直接使用百度搜索即可.果然还是自家人懂得自家事,找到了很多内容. //step 0:cd 到你安装SDK目录的Tools目录下(例如:/Volumes/work/sdk/tools) //step 1:设置代理获取可更新列表 ./android list sdk --extended --proxy-host android-mirror.bugly.qq.com --proxy-port 8080 -s //step 2:设置更新代理并选择下载文件,我这里选择的所有 -a ./android update sdk --proxy-host android-mirror.bugly.qq.com --proxy-port 8080 -s -u -a //当然你也可以自定义参数 Updates the SDK by suggesting new platforms to install if available. Options: -f --force : Forces replacement of a package or its parts, even if something has been modified. -n --dry-mode : Simulates the update but does not download or install anything. --proxy-host: HTTP/HTTPS proxy host (overrides settings if defined) -s --no-https : Uses HTTP instead of HTTPS (the default) for downloads. -t --filter : A filter that limits the update to the specified types of packages in the form of a comma-separated list of [platform, system-image, tool, platform-tool, doc, sample, source]. This also accepts the identifiers returned by &apos;list sdk --extended&apos;. -u --no-ui : Updates from command-line (does not display the GUI) --proxy-port: HTTP/HTTPS proxy port (overrides settings if defined) -p --obsolete : Deprecated. Please use --all instead. -a --all : Includes all packages (such as obsolete and non-dependent ones.) //step 3:同意license内容,反正你也没的选,然后就会自动下载并解压 Do you accept the license &apos;android-sdk-preview-license-52d11cd2&apos; [y/n]: 这里代理服务器其实蛮多的,参考AndroidDev,不懂翻墙人士的福音.深圳地区设置腾讯代理以后下载速度基本上都是2-3M起,速度非常快. 使用上面命令行是因为Linux Server没有可用图形操作界面,如果有图形操作界面的话还是不要使用这种方式了,把时间花在更有用的地方吧!毕竟我们是一群需求没定好就能把项目做完的码农! 使用sdkmanagersdkmanager是谷歌推出的新的工具，以前的android工具已经是deprecated状态，所以大家尽量切换到新的sdkmanager进行管理。同样的，我们也要对工具进行代理才能够正常的更新。 123456//获取所有的工具列表sdkmanager --list --no_https --proxy=http --proxy_host=g.cn --proxy_port=80//安装指定的工具（&quot;platforms;android-28&quot;）sdkmanager &quot;platforms;android-28&quot; --no_https --proxy=http --proxy_host=g.cn --proxy_port=80//也可以同时指定安装多个工具sdkmanager &quot;platforms;android-28&quot; &quot;build-tools;28.0.3&quot; --no_https --proxy=http --proxy_host=g.cn --proxy_port=80 如下所示： 使用阿里云仓库阿里云仓库地址 http://maven.aliyun.com/mvn/view， gradle版本的一些说明 https://developer.android.com/studio/releases/gradle-plugin 123456//替换jcenter()maven &#123;url &apos;https://maven.aliyun.com/repository/jcenter&apos;&#125;//替换google(),从gradle3.0.0开始就需要添加谷歌仓库maven &#123;url &apos;https://maven.aliyun.com/repository/google&apos;&#125;//公共仓库maven &#123;url &apos;https://maven.aliyun.com/repository/public&apos;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自动构建</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-拷贝文件Buff-Size最佳实践]]></title>
    <url>%2F2017%2F01%2F18%2FAndroid-%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6Buff-Size%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[因为在我们的项目里面有一个大小超过11M的assets可执行文件,所以在app初次安装或者版本升级的时候需要全新拷贝或者升级拷贝.在实际使用中发现在app覆盖安装的时候重新拷贝assets文件很容易出现拷贝不完整的问题,这会导致这个可执行文件运行出现错误,最直观的表现就是界面数据展示异常,且只能通过卸载重装或者清除数据重新生成这个可执行文件解决异常,所以后来我就进行了一些优化. 1.加入文件完整性校验最开始的时候首先想到的是对文件进行完整性校验,即通过文件的MD5值进行对比,观察生成的完整的可执行文件的MD5值是否发生了改变来进行判断.如果MD5值出现改变则提示用户初始化失败,强制关闭app并且重新生成可执行文件.这里有一点补充的是之所以有这个分割成1M文件是因为在Android2.3之前单个assets文件大小不能超过1M,参考资料看这里. 拷贝代码例子如下,当然在我们的项目中还应该有一个分割和合并的过程,具体的代码就不再这里详细的写出来了: File Path = Ctxt.getDir(&quot;Data&quot;, 0); File DBFile = new File(Path, &quot;database.db&quot;); if(!DBFile.exists() || DatabaseNeedsUpgrade) //Need to copy... CopyDatabase(Ctxt, DBFile); ​ static private void CopyDatabase(Context Ctxt, File DBFile) throws IOException { AssetManager assets = Ctxt.getAssets(); OutputStream outstream = new FileOutputStream(DBFile); DBFile.createNewFile(); byte []b = new byte[1024]; int i, r; String []assetfiles = assets.list(“”); Arrays.sort(assetfiles); for(i=1;i&lt;10;i++) //I have definitely less than 10 files; you might have more { String partname = String.format(“%d.db”, i); if(Arrays.binarySearch(assetfiles, partname) &lt; 0) //No such file in assets - time to quit the loop break; InputStream instream = assets.open(partname); while((r = instream.read(b)) != -1) outstream.write(b, 0, r); instream.close(); } outstream.close(); } 2.考虑不分割文件前面有提到其实只有在Android2.3之前才有assets单个文件大小不能超过1M的限制,而拷贝过程通常都是在进行到其中的某个文件时就失败了,所以考虑不分割文件直接进行拷贝.在实际测试中发现并没有什么大的改善,甚至于拷贝速度还下降了. 3.从拷贝的过程入手通常我们拷贝文件的时候都会使用int数组进行缓存加速拷贝过程,但是这个缓存的大小究竟要设置为多大比较合适可能大家都没怎么想过.正常来说在设备允许的情况下当然是越大越好,但实际使用过程中,我们也要考虑增大缓存带来的收益.通过测试和查阅资料发现,在使用32K缓存大小的情况下收益是最好的.大幅度的提升了拷贝速度,后面我们基本上没有遇到过由于文件拷贝不完整导致的启动异常问题.如下表所示,对应不同缓存拷贝20M文件的耗时: ​ 128 256 512 1K 2K 4K 8K 16K 32K 64K 128K 256K 512K 1M 2M 4M 8M 16M Galaxy S 4047 3060 269 155 100 65 64 52 51 45 47 50 49 43 44 46 45 58 Optimus LTE 1178 617 322 172 101 65 47 42 41 35 36 39 44 61 56 51 72 60 HTC EVO 3971 1884 941 480 251 141 95 69 56 50 48 55 50 49 48 48 48 47 Galaxy S2 750 383 210 123 74 50 41 37 35 34 34 37 39 44 46 44 45 44 Galaxy Nexus 2272 1216 659 341 187 108 70 52 41 38 38 45 44 54 56 66 68 58 Galaxy Note 1549 799 404 220 127 75 58 54 52 56 52 45 44 62 43 39 44 46 可以发现,32K缓存拷贝文件的收益是极高的,对手机内存的压力也比较小.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建跨平台go编译环境]]></title>
    <url>%2F2017%2F01%2F18%2F%E6%90%AD%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0go%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[本文主要是为了搭建golang跨平台环境,从而实现一套golang代码运行在多重环境(OSX,Linux,Android,iOS,Windows),实现跨平台共享代码,简化开发流程. 安装Docker 安装golang 安装xgo镜像及编译指令 配置环境变量 1. 安装docker针对Mac和Windows可以直接下载安装包进行安装,其他系统可以使用命令行进行安装.参考链接,最后通过docker version 指令进行查看 # Jacen at EveeedeMacBook-Pro.local in ~ [10:51:52] docker version Client: Version: 1.12.5 API version: 1.24 Go version: go1.6.4 Git commit: 7392c3b Built: Fri Dec 16 06:14:34 2016 OS/Arch: darwin/amd64 Server: Version: 1.12.5 API version: 1.24 Go version: go1.6.4 Git commit: 7392c3b Built: Fri Dec 16 06:14:34 2016 OS/Arch: linux/amd64 2. 安装golang同样的在Windows和Mac下面都有一键安装包,针对其他系统也是通过命令行进行安装.参考链接,安装好以后还需要进行环境变量的配置. 在mac系统和Linux系统下面,Windows配置环境变量 export GOROOT=&quot;/usr/local/go&quot; export GOPATH=&quot;你的工作目录&quot; //这里主要是影响到后面需要安装的xgo 再执行go env查看是否配置成功: GOARCH=&quot;amd64&quot; GOBIN=&quot;&quot; GOEXE=&quot;&quot; GOHOSTARCH=&quot;amd64&quot; GOHOSTOS=&quot;darwin&quot; GOOS=&quot;darwin&quot; GOPATH=&quot;/Volumes/Work/go&quot; GORACE=&quot;&quot; GOROOT=&quot;/usr/local/go&quot; GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot; CC=&quot;clang&quot; GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/w4/75xgx41n2bb7mm3m0dxbp0d40000gn/T/go-build003828011=/tmp/go-build -gno-record-gcc-switches -fno-common&quot; CXX=&quot;clang++&quot; CGO_ENABLED=&quot;1&quot; 3. 安装xgo docker镜像xgo的docker镜像是我们真正的编译环境,Github地址 安装xgo docker镜像,这个镜像大概4.xG,需要花较长的时间下载 docker pull karalabe/xgo-latest 这里latest指的最新的编译环境,如果需要的话也可以指定安装具体版本的镜像,在这里,这个版本的差异主要是golang版本的不同,由于编译的时候可以指定golang版本进行编译,所以我们直接安装最新版本即可. 安装xgo go get github.com/karalabe/xgo 安装xgo编译工具,这个工具封装了go build,简化了我们的操作. 4. 配置环境变量如果我们使用的是bash的话可以将环境变量配置到.bash_profile中,免去export的过程 使用bash 在 ~ 目录下编辑.bash_profile 文件,在末尾添加 export GOPATH=”你的工作目录” export GOROOT=”usr/local/go” export PATH=$PATH:$GOPATH/bin export GOROOT_BOOTSTRAP=$GOROOT source .bash_profile使得配置文件生效 使用如zsh shell程序 在~ 目录下编辑.zshrc 文件,添加上面同样的文件 同上source生效 5. 测试xgo交叉编译环境是否OK$ cd $GOPATH/src // If you have multiple (I have at least 3 in there), change into any, doesn&apos;t matter $ mkdir xgo_test $ cd xgo_test $ echo -e &apos;package main\n import &quot;fmt&quot;\n func main(){\nfmt.Println(&quot;Hello&quot;)\n}&apos; &gt; main.go $ xgo . 执行完上述命令后在当前目录查看是否有编译生成的可执行文件 6. 打包 ~ xgo /Volumes/Public\ Storage/go/src/zhjd() ~ xgo --targets=android-14/arm /Volumes/Storage/go/src/zhjd 指定生成Android端专用的会快很多很多,这里的14指的是最小支持SDK版本 Checking docker installation... Client: Version: 1.12.3 API version: 1.24 Go version: go1.6.3 Git commit: 6b644ec Built: Wed Oct 26 23:26:11 2016 OS/Arch: darwin/amd64 Server: Version: 1.12.3 API version: 1.24 Go version: go1.6.3 Git commit: 6b644ec Built: Wed Oct 26 23:26:11 2016 OS/Arch: linux/amd64 Checking for required docker image karalabe/xgo-latest... found. Cross compiling zhjd... Building locally zhjd... Assembling toolchain for android-16/arm... Bootstrapping android-16/arm... Compiling for android-16/arm... Assembling toolchain for android-16/386... Bootstrapping android-16/386... Compiling for android-16/386... No API C header specified, skipping android-16/aar... 重点关注 Compiling for linux/amd64... Compiling for linux/386... Bootstrapping linux/arm-5... Compiling for linux/arm-5... Cleaning up Go runtime for linux/arm-5... Bootstrapping linux/arm-6... Compiling for linux/arm-6... Cleaning up Go runtime for linux/arm-6... Bootstrapping linux/arm-7... Compiling for linux/arm-7... Cleaning up Go runtime for linux/arm-7... Compiling for linux/arm64... Compiling for linux/mips64... Compiling for linux/mips64le... Compiling for windows-4.0/amd64... Compiling for windows-4.0/386... Compiling for darwin-10.6/amd64... Compiling for darwin-10.6/386... Bootstrapping ios-5.0/arm-7... # runtime/cgo ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE # net ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE # os/user ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE Compiling for ios-5.0/arm-7... # github.com/mattn/go-sqlite3 ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE # github.com/mattn/go-sqlite3 ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE Cleaning up Go runtime for ios-5.0/arm-7... Bootstrapping ios-5.0/arm64... # runtime/cgo ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE # net ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE # os/user ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE Compiling for ios-5.0/arm64... # github.com/mattn/go-sqlite3 ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE # github.com/mattn/go-sqlite3 ldid.cpp(602): _assert(): Swap(mach_header_-&gt;filetype) == MH_EXECUTE || Swap(mach_header_-&gt;filetype) == MH_DYLIB || Swap(mach_header_-&gt;filetype) == MH_BUNDLE Cleaning up Go runtime for ios-5.0/arm64... Cleaning up build environment... 查看编译生成的文件 ➜ all ls -al total 427872 drwxr-xr-x 21 silence staff 714 Dec 29 11:37 . drwxr-xr-x+ 29 silence staff 986 Dec 29 11:37 .. -rw-r--r--@ 1 silence staff 6148 Dec 29 11:37 .DS_Store -rwxr-xr-x 1 silence staff 14633608 Dec 29 11:27 zhjd-android-16-386 drwxr-xr-x 5 silence staff 170 Dec 29 11:27 zhjd-android-16-aar -rwxr-xr-x 1 silence staff 14705872 Dec 29 11:26 zhjd-android-16-arm -rwxr-xr-x 1 silence staff 10418780 Dec 29 11:32 zhjd-darwin-10.6-386 -rwxr-xr-x 1 silence staff 11578172 Dec 29 11:31 zhjd-darwin-10.6-amd64 -rwxr-xr-x 1 silence staff 11224720 Dec 29 11:34 zhjd-ios-5.0-arm64 -rwxr-xr-x 1 silence staff 10569184 Dec 29 11:33 zhjd-ios-5.0-armv7 drwxrwxrwx 3 silence staff 102 Dec 29 11:35 zhjd-ios-5.0-framework -rwxr-xr-x 1 silence staff 14611432 Dec 29 11:28 zhjd-linux-386 -rwxr-xr-x 1 silence staff 17246480 Dec 29 11:27 zhjd-linux-amd64 -rwxr-xr-x 1 silence staff 13034956 Dec 29 11:28 zhjd-linux-arm-5 -rwxr-xr-x 1 silence staff 12965808 Dec 29 11:29 zhjd-linux-arm-6 -rwxr-xr-x 1 silence staff 12939788 Dec 29 11:29 zhjd-linux-arm-7 -rwxr-xr-x 1 silence staff 17075720 Dec 29 11:29 zhjd-linux-arm64 -rwxr-xr-x 1 silence staff 18700376 Dec 29 11:30 zhjd-linux-mips64 -rwxr-xr-x 1 silence staff 18699640 Dec 29 11:31 zhjd-linux-mips64le -rwxr-xr-x 1 silence staff 9734407 Dec 29 11:31 zhjd-windows-4.0-386.exe -rwxr-xr-x 1 silence staff 10889885 Dec 29 11:31 zhjd-windows-4.0-amd64.exe 可以发现,针对不同平台生成了不同类型的文件.Android支持生成aar库文件,iOS支持生成Framework库文件 平台实测Android端测试 推送到设备中,之所以不直接推送到app目录下是因为权限问题,这里如果提示adb命令不存在同样的也要把Android SDK中的adb命令配置到环境变量中 //直接推送到app目录下会有权限问题 adb push zhjd-android-16-arm data/data/com,kingdee.zhihuiji adb: error: failed to copy &apos;zhjd-android-16-arm&apos; to &apos;data/data/ com.kingdee.zhihuiji&apos;: Permission denied //所以推送到该目录下 adb push zhjd-android-16-arm data/local/tmp [100%] data/local/tmp/zhjd-android-16-arm 切换到Android设备并执行该文件,这里只能使用已经root的设备 adb shell 进入手机命令行 su 切换超级用户 cd /data/local/tmp ./zhjd-android-16-arm 最后在终端会输出可执行文件的执行结果]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Golang</tag>
        <tag>CrossCompile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Library中的R文件不是常量]]></title>
    <url>%2F2017%2F01%2F18%2FAndroid-Library%E4%B8%AD%E7%9A%84R%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前段时间跟项目老大提了个请求,就是将Butterknife加入到我们的项目中,结合android-butterknife-zelezny使用,这样子不仅代码简洁,也可以减少一些findViewById的繁琐过程,提升我们的开发效率.效果如下图,是不是特别简洁. 经过老大的同意以后,我开始加依赖,下载自动注解插件,进行自动生成代码,一气呵成,神清气爽.But问题立马就暴露出来了,代码如下: @OnClick({R2.id.m_button_pattern, R2.id.m_button_password}) public void onClick(View view) { Log.d(&quot;xx&quot;, &quot;========onClick=========&quot;); Intent intent = new Intent(); switch (view.getId()) { case R2.id.m_button_pattern: intent.setClass(getApplicationContext(),MainActivity.class); Log.d(&quot;xx&quot;, &quot;========onClick====MainActivity=====&quot;); break; case R2.id.m_button_password: intent.setClass(getApplicationContext(),SetPasswordLockActivity.class); Log.d(&quot;xx&quot;, &quot;========onClick=====SetPasswordLockActivity====&quot;); break; } this.startActivity(intent); } 然后问题就出现了.由于我们的项目是在Library中开发(蛋疼得不行,很多限制),问题就是出在这里,请看下面的代码: //Library中生成的R文件 public static int activity_open_exit=0x7f04000d; //Module中生成的R文件 public static final int abc_fade_out=0x7f050001; 所以在Library中无法使用switch语句进而影响到了Butterknife的使用. 至于为什么在Library中无法使用参考谷歌文档.经过阅读我们知道从ADT14开始Library中的R文件才从静态常量变为非常量.因为如果在多个Library中可能出现id冲突的问题.在ADT14以前则采用的是将所有的资源文件和相关的代码重新随着主项目一起重新编译,导致编译速度过慢.因此,从ADT14开始就变成了非常量的id了: int id = view.getId(); switch (id) { case R.id.button1: action1(); break; case R.id.button2: action2(); break; case R.id.button3: action3(); break; } Android Studio也提供了一键转换的快捷方式如下图: 然后就变成了如下所示的代码了. int id = view.getId(); if (id == R.id.button1) { action1(); } else if (id == R.id.button2) { action2(); } else if (id == R.id.button3) { action3(); } 因为找资料的原因又去看了下Github的Butterknife, JakeWharton大神终于在大家的强烈请求下更新了支持Library, 更新日志; Version 8.2.0 (2016-07-10) New: Support for library projects. Requires application of a Butter Knife Gradle plugin. See README for details. New: Generated code now emits R references instead of raw integer IDs. Fix: @OnPageChange listener binding now uses the &apos;add&apos;/&apos;remove&apos; methods on ViewPager instead of &apos;set&apos;. 算是意料之外的惊喜吧,下周一就把Butterknife加入我们的项目!]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搭建gomobile开发环境]]></title>
    <url>%2F2017%2F01%2F18%2F%E6%90%AD%E5%BB%BAgomobile%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[gomobile是谷歌开发的一种跨平台技术解决方案,可以针对iOS和Android平台进行直接开发或者进行Library开发. 配置gomobile开发环境 设置终端http,https代理 配置git,及环境变量 配置golang及gopath环境及环境变量 配置gomobile及环境变量 gomobile的优缺点优点 直接构建用于ios的framework文件,可以直接调用生成的类 直接构建用于Android的aar文件,使用jni直接调用 统一三端规则,避免重复开发和一些错误 缺点:数据类型限制 int and float; string and boolean; byte[]. The current implementation doesn’t allow to use []byte as the function argument (https://golang.org/issues/12113); function has to return only supported types, it may not return the result, it may return one or two types wherein the second type should be an error; interfaces could be used if they are exported to files of any supported type; struct type, only in case all fields meet the constraints. ] 环境搭建流程官方教程 官网地址,安装gomobile,当然首先得安装golang才能够使用go命令 $ go get golang.org/x/mobile/cmd/gomobile $ gomobile init //然后就可以通过gomobile指令查看了 $ gomobile 前面地址进不去的话有个Github地址 使用Github镜像安装由于使用谷歌的官网资源需要在命令行翻墙,比较麻烦,所以直接使用Github的镜像进行安装. $ mkdir -p $GOPATH/src/github.com/golang $ cd $GOPATH/src/github.com/golang $ git clone https://github.com/golang/mobile.git $ mkdir -p $GOPATH/src/golang.org/x $ cp -r $GOPATH/src/github.com/golang/mobile $GOPATH/src/golang.org/x $ cd $GOPATH/src/golang.org/x/mobile/cmd/gomobile $ go install //会在$GOPATH/src/bin 目录下生成gomobile $ gomobile init //安装NDK之类的]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo-搭建博客相关]]></title>
    <url>%2F2017%2F01%2F18%2Fhexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[常用的命令hexo new post &quot;article title&quot; //创建新的post,创建目录为: /source/_posts/ hexo d //deploy 发布 hexo s // hexo clean hexo s --debug hexo new page categories hexo new page about hexo new page commonweal hexo new page sitemap hexo new page tags hexo new page archives hexo new page tags]]></content>
      <categories>
        <category>博客编写</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X 配置环境变量]]></title>
    <url>%2F2017%2F01%2F16%2Farticle-title%2F</url>
    <content type="text"><![CDATA[/etc/bashrc 是针对系统所有用户的全局变量，只有root用户才能修改这两个文件，对一般用户来说是他们是只读的。一般用户要想修改它们，可以在命令前加sudo，意思是以Root身份执行，比如：sudo vi /etc/profile ，然后按照提示输入密码即可。(以上是针对使用默认shell的用户,如果使用zsh的话则对应的修改文件是.zshrc) 因此，对于一般用户而言，通常我们建议去修改~/.bash_profile来设置环境变量，它是用户级的设置，只对当前用户有效。操作步骤: 1、打开Terminal（终端） 2、输入：vi ~/.bash_profile 3、设置PATH：export PATH=/usr/local/mysql/bin:$PATH 4、输入：:wq //保存并退出vi 5、修改立即生效：source ~/.bash_profile 6、查看环境变量的值：echo $PATH]]></content>
      <categories>
        <category>Shell</category>
      </categories>
  </entry>
</search>
