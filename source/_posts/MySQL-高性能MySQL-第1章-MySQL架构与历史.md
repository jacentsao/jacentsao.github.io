---
title: MySQL-高性能MySQL-第1章-MySQL架构与历史
date: 2019-03-24 15:51:40
tags: [MySQL]
categories: MySQL
---

本章该要地描述了MySQL的服务器架构、各种存储引擎之间的主要区别，以及这些区别的重要性。

<!--more-->

#### 1.1 MySQL逻辑架构

下图为MySQL的服务器逻辑架构图：

![](https://raw.githubusercontent.com/jacentsao/picbed/master/img/markdownLogical%20view%20of%20the%20MySQL%20Server%20architecture.png)

**第一层为客户端** - 连接/线程处理，这一部分其实代表了绝大多数的基于网络的客户端/服务器的工具或者服务。例如连接处理、授权认证、安全等等。

**第二层是MySql的核心服务功能。**包括了查询解析、优化、分析、缓存以及所有的内置函数（六，日期、时间、数学和加密函数），所有跨存储引擎的功能都是在这一层实现的：存储过程、触发器、视图等等。

**第三层包含了存储引擎。**存储引擎负责MySql中数据的提取和存储，各个存储引擎都有自己的优势和劣势，服务器通过api与存储引擎进行通信，api屏蔽了存储引擎之间的差异，是的这些差异对于上层的查询过程透明。存储引擎不会解析sql(InnoDB例外，因为InnoDB会解析外键定义，而MySql服务器本身并没有实现这个功能)

#### 1.2 并发控制

MySQL在两个层面进行并发控制：服务器层和存储引擎层。在并发场景下通过锁机制来进行控制，针对并发读和写的场景分别使用共享锁（shared lock）和排它锁（exclusive lock）也称之为读锁（read lock）和写锁（write lock）。

通过锁机制可以保证并发场景下的数据安全性问题，但是由于锁本身会占用系统资源，所以锁本身会影响到系统的执行效率。MySQL会在锁的开销和数据的安全性之间寻求平衡，这就是所谓的锁策略。

MySQL最终要的两种锁策略如下：

**表锁（table lock）**

表锁时MySQL中最基本的锁策略，并且是开销最小的策略。在这种策略下，写锁具有比读锁更高的优先级。

**行级锁（row lock）**

行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。

#### 1.3 事务

事务就是一组原子性的SQL查询，或者说一个独立的工作单元，即在一个事务内的语句，要么全部执行成功，要么全部执行失败。

事务本身应该满足ACID原则：

**原子性（atomic）**：要么全部执行成功，要么全部执行失败。
**一致性（consistency）**：数据库总是从一个一致性状态抓换到另一个一致性状态。
**隔离性（isolation）**：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
**持久性（durability）**：一旦事务提交，则其所有的修改就会永久保存到数据库中。

##### 1.3.1 隔离级别

对比如下：

![image](https://raw.githubusercontent.com/jacentsao/picbed/master/img/markdown20190505231000%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png)


###### READ UNCOMMITED（未提交读）

事务可以读取未提交的数据，称为脏读（Dirty Read）。性能没有特别大的提升，缺少突出优点。

###### READ COMMMITED（提交读）

大多数数据库系统的默认隔离级别就是READ COMMITED（MySQL不是，[原因：MySQL使用可重复读来作为默认隔离级别的主要原因是语句级的Binlog。RR能提供SQL语句的写可串行化，保证了绝大部分情况（不安全语句除外）的DB/DR一致。](https://www.cnblogs.com/vinchen/archive/2012/11/19/2777919.html)）。即一个事务开始时，只能“看见”已经提交的事务所做的修改，也称为不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。

###### REPETABLE READ（可重复读）

RC解决了脏读的问题，保证了在同一个事务中多次读取同样的记录是一致的。但是无法解决幻读的问题（Phantom Ready）。所谓幻读是指在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。

###### SERILIZABLE（可串行化）

最高的隔离级别，通过事务串行化，避免了前面说的幻读问题。


##### 1.3.2 死锁

死锁是指两个或者多个事务在统一资源上的相互占用，并请求锁定对方占用的资源。死锁的处理跟存储引擎有关。

##### 1.3.3 事务日志

事务日志可以帮助提高事务的效率。