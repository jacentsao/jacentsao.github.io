---
title: java-深入理解Java虚拟机-线程安全与锁优化
date: 2019-03-18 09:08:30
tags: [java,jvm]
categories: java
---


### 13.2 线程安全

当多个线程访问 一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其它的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。这是Java Concurrency In Practice一书中作者Brian Goetz对“线程安全”的定义。

#### 13.2.1 Java语言中的线程安全

按照线程安全的“安全程度”由强至弱来排序，可以讲Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

**1.不可变**

在Java API中符合不可变要求的类型，有String类型，final修饰的基本变量，final修饰属性的对象，枚举类，以及java.lang.Number的部分子类，如Long，Double，BigInteger，BigDecimal（其中AtomicInteger和AtomicLong并非是不可变的）

**2.绝对线程安全**

一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。例如Vector的get()、remove()和size()方法都是同步的，但是在多线程的环境下，如果不在方法调用端坐额外的同步措施的话，使用这段代码仍然是不安全的。因为如果另一个线程恰好在错误的时间里删除了一个元素，当前线程去访问的话会出现ArrayIndexOutOfBoundsException

**3.相对线程安全**

相对线程安全就是我们通常意义上所讲的线程安全，它需要保证这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collection的synchronizedCollection()方法包装的集合等。

**4.线程兼容**

线程兼容是指对象本身并不是线程安全的，但是可以通过调用端正确地使用同步手段来保证对象在并发环境下的安全使用。

Java API中大部分的类都是属于线程兼容的。

**5.线程对立**

线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。这种现象是少见的，有害的，应当尽量避免。

一个线程对立的例子就是Thread类的suspend()和resume()方法，如果两个线程同时持有一个对象，一个尝试去中断线程，另一个尝试去恢复线程，并发时，无论是否采取了同步措施，都有可能死锁。常见的线程对立操作还有System.setIn()、System.setOut()和System.runFinalizersOnExit()等。

#### 13.2.2 线程安全的实现方法

**1.互斥同步（MutualExclusion&Synchronization）**

同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方法。因此，互斥是因，同步是果；互斥是方法，同步是目的。

Java中，最常见的互斥同步方式是使用synchronized关键字，synchronized关键字编译生成字节码后会在同步块前后分别生成monitorenter和monitorexit两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。在Java编程中，如果明确指定了synchronized的对象参数，那就是这个对象的reference；如果没有明确指定，就根据synchronized修饰的是实例方法还是类方法，去取相应的对象实例或Class对象来做为锁对象。

monitorenter时锁计数器加1，monitoexit时锁计数器减1，计数器为0是锁被释放。如果获取对象锁失败，则当前线程阻塞等待，直到另一个线程释放对象锁。

在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点需要特别注意：

* 同步块对同一条线程时可重入的，不会出现锁死的问题。
* 同步块在已进入的线程释放对象锁之前，会阻塞其它线程的进入。

由于Java的线程都是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，需要从用户态切换到核心态，这是一个比较重的操作。

除了synchronized之外，还可以通过java.util.concurrent包中的重入锁（ReentrantLock）来实现同步，两者基本使用方式一致，只是在代码写法上有点区别，一个表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块完成），另一个表现为原生语法层面的互斥锁。相比synchronized，ReentrantLock增加了多项高级功能，主要有如下3个：

* 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的锁可以放弃等待改为处理其它事情。
* 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。可以通过构造参数控制是否使用公平锁。Synchronized是非公平的，抢占式的。
* 锁绑定多个条件：一个ReentrantLock对象可以绑定多个Condition对象。Synchronized只能绑定一个条件。

不过从jdk1.6开始，虚拟机对synchronized优化较多，所以synchronized更适合我们的使用。

**2.非阻塞同步**

互斥同步最主要的问题就是进行线程阻塞和唤醒锁带来的性能问题，这种方式称为阻塞同步（Blocking Synchronization）。互斥同步是一种悲观锁，无论共享数据是否真的会出现竞争，都要进行加锁（这里说的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态装换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

随着**硬件指令集**的发展，出现了一种基于冲突检测的乐观并发策略。通俗来说，就是先进行操作，等到检测到冲突再采取补偿措施（常见的补偿措施就是不断重试，直到成功），这种同步方式称为非阻塞同步（Non-Blocking Synchronization）。

乐观并发策略需要“硬件指令集的发展”的原因是，我们需要操作和冲突检测这两个步骤具有原子性。硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：

* 测试并设置（Test-and-Set）
* 获取并增加（Fetch-and-Increment）
* 交换（Swap）
* 比较并交换（Compare-and-Swap，下文称为CAS）
* 加载链接/条件存储（Load-Linked/Store-Conditionl，下文称LL/SC）

前三条时20世纪就存在于大多数指令集之中的处理器指令，后面两条时现代处理器新增的。

CAS指令需要三个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预估值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值更新V的值，否则就不执行更新，但是都回返回V的旧值，上述操作时是一个原子过程。

在Java中使用CAS编译出来的结果是一条与平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联（别虚拟机特殊处理的方法称为固有函数（Intrinsics），类似的还有Math.sin()方法等）进去了。

CAS还存在一个逻辑漏洞，如果V初次读取的时候是A值，准备赋值的时候还是A值，但是它有可能被多次修改最终改为A值，这个漏洞称为CAS操作的“ABA”问题。一般通过控制变量的版本来保证CAS的正确性，对应的java.util. concurrence中的AtomicStampedReference类。

**3.无同步方案**

**可重入代码（Reentrant Code）**这种代码也称为（Pure Code），即一个方法，它的返回结果时可以预测的，输入相同的数据，都能返回相同的结果。

**线程本地存储（Thread Local Storage）**不共享变量，每一个线程都有自己的专享变量，例如ThreadLocal。

### 13.3 锁优化

高效并发是从JDK1.5到JDK1.6的一个重要改进，这个版本有各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等。

#### 13.3.1 自旋锁与自适应自旋

为了保持处理器执行时间，线程忙循环（自旋），这就是所谓的自旋锁。自旋锁会占用处理器执行时间，因此超过一定次数以后放弃自旋，最开始的时候默认为10次自旋。

JDK 1.6中引入了自适应的自旋锁，这种情况下考验的是虚拟机对程序锁的状况预测能力，预测能力越好，效率越高。

#### 13.3.2 锁消除

锁消除是指虚拟机即使编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。

比如说字符串拼接的时候调用的concatString方法，内部使用StringBuffer对象的append()方法，append()方法是带锁的，如果分析得出不会逃逸到concatString方法之外，那么锁是可以消除的。

#### 13.3.3 锁粗化

通常来说锁的粒度越小越好，但是涉及到循环这种操作的时候，就要将锁粗化，防止反复加锁，释放锁带来的额外性能损失。

#### 13.3.4 轻量级锁

轻量级锁时JDK1.6之中加入的新型锁机制，“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制被称为“重量级”锁。需要强调的一点是，轻量级锁并不是用来代替重量级锁的，它的本意实在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

轻量级锁本意是为了减少多线程进入互斥的几率，利用了CPU原语Compare-And-Swap（CAS，汇编指令CMPXCHG），尝试在进入互斥前，进行补偿